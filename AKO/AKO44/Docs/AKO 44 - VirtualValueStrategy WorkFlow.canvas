{
	"nodes":[
		{"id":"5d444fb624308fbf","type":"text","text":"Esta clase sirve para elegir “cómo calcular” según el tipo de dispositivo. Al construirse, guarda las estrategias disponibles en un diccionario usando `deviceType` como clave. Luego, cuando le pasas un `deviceType`, te devuelve la estrategia correspondiente para usarla en el cálculo de valores virtuales. Si no existe una estrategia para ese tipo, no podrá calcularlos.\n\n```js\nimport { DeviceType } from \"../types/sp-types\";\nimport { VirtualValueStrategy } from \"./strategy/virtualValueStrategy\";\n\nexport class VirtualValueStrategyFactory {\n  // Mapa: para cada tipo de dispositivo guardamos la estrategia que sabe calcular sus “virtual values”.\n  // Partial = puede que no exista estrategia para todos los DeviceType.\n  private strategies: Partial<Record<DeviceType, VirtualValueStrategy>> = {};\n\n  constructor(strategies: VirtualValueStrategy[]) {\n    // Registra cada estrategia usando su deviceType como clave.\n    // Ej: si s.deviceType = \"12830\", queda strategies[\"12830\"] = s\n    for (const s of strategies) {\n      this.strategies[s.deviceType] = s;\n    }\n  }\n  // Devuelve la estrategia asociada al tipo de dispositivo.\n  // Si no hay una registrada para ese tipo, devolverá undefined en runtime.\n  getStrategy(deviceType: DeviceType): VirtualValueStrategy {\n    return this.strategies[deviceType];\n  }\n}\n```","x":-422,"y":-180,"width":702,"height":240},
		{"id":"75163d2b0255524f","x":-422,"y":-420,"width":702,"height":119,"type":"text","text":"El valor virtual son valores calculador para diferentes parámetros que dependiendo del punto en el que esta si por arriba o por abajo del valor objetivo se utiliza una estrategia u otra. Para el calculo de estos utilizamos un patron `Strategy` [[Arquitectura y diseño#^81cb34]] implementando la clase `VirtualValueStartegyFactory`"},
		{"id":"7ce54f0fb582f936","type":"text","text":">[!example] TypeScript Record\n\n>```js\n>private strategies: Partial<Record<DeviceType, VirtualValueStrategy>> = {};\n>```\n>\n>Recurso [[TypeScript - Main Site#^b87f0d]]","x":440,"y":-520,"width":702,"height":200},
		{"id":"2e111d782191e0dc","x":571,"y":-190,"width":440,"height":260,"type":"text","text":">[!tip] VirtualValueStrategy\n>![[Pasted image 20260224101703.png]]"},
		{"id":"795185c8b0afafd9","type":"text","text":"\nAquí se deja preparada la “lista de reglas” para calcular valores virtuales. Se carga una estrategia concreta (la común), y más adelante el micro la usará automáticamente cuando procese muestras de ese tipo de dispositivo.\n```js\n// Crea la factory (selector) de estrategias y registra la estrategia “común”.\n// Esa estrategia se usará cuando el dispositivo sea del tipo que ella define (deviceType = \"12830\").\nthis.virtualStrategyFactory = new VirtualValueStrategyFactory([\n  new CommonVirtualValueStrategy(),\n]);\n```","x":-1460,"y":-480,"width":702,"height":240},
		{"id":"36f6083b966fc2a1","type":"text","text":"Esta clase define cómo calcular “valores virtuales” para dispositivos del tipo `12830`. Tiene una tabla (`ttiValuesMap`) que dice qué lectura real (prb1) y qué parámetros (setpoint y delta) usar para cada virtual value TTI. La función `calculateVirtualValues` recibe el sample, la configuración y las definiciones de virtuals, convierte el timestamp y devuelve la lista de valores derivados calculados (en este caso, por la parte analógica).\n\n```js\nexport class CommonVirtualValueStrategy implements VirtualValueStrategy {\n  // Esta estrategia solo aplica a dispositivos de este tipo\n  readonly deviceType = \"12830\";\n\n  private logger = new LoggerHelper(\"CommonVirtualValueStrategy\");\n\n  // Refs/params que se usan como “ingredientes” para calcular valores derivados\n  private static readonly PARAM_SETPOINT = \"reg_amv_analog_actual_sp\";   // setpoint que llega en el sample\n  private static readonly PARAM_DELTA = \"param_C1_sp_delta\";            // delta que viene de la conf\n  private static readonly PARAM_ALARM_MAX = \"param_A1_alarm_prb1_max\";  // alarma max en conf\n  private static readonly PARAM_ALARM_MIN = \"param_A2_alarm_prb1_min\";  // alarma min en conf\n\n  // Tabla: para cada virtual value (ref) indica qué señal real usar y qué setpoint/delta aplicar\n  private static readonly ttiValuesMap = new Map<string, TtiValueConfig>([\n    [\"reg_cloud_virtual_value_tti_above\",  { setpoint: CommonVirtualValueStrategy.PARAM_SETPOINT, delta: CommonVirtualValueStrategy.PARAM_DELTA, ref: \"reg_amv_analog_prb1\" }],\n    [\"reg_cloud_virtual_value_tti_bellow\", { setpoint: CommonVirtualValueStrategy.PARAM_SETPOINT, delta: CommonVirtualValueStrategy.PARAM_DELTA, ref: \"reg_amv_analog_prb1\" }],\n    [\"reg_cloud_virtual_value_tti_in\",     { setpoint: CommonVirtualValueStrategy.PARAM_SETPOINT, delta: CommonVirtualValueStrategy.PARAM_DELTA, ref: \"reg_amv_analog_prb1\" }],\n  ]);\n\n  calculateVirtualValues(\n    sample: AnalogInput[] | DigitalInput[],\n    digital?: boolean,\n    timestamp?: Date,\n    conf?: Record<string, string | number>,\n    virtualValueDefinitions?: VirtualValueDefinition[],\n  ): VirtualValue[] {\n    const result: VirtualValue[] = [];\n\n    // Asegura que timestamp sea un Date (si viene como string/number lo convierte)\n    const ts = timestamp instanceof Date ? timestamp : new Date(timestamp);\n\n    // En este fragmento, calcula solo virtual values a partir de entradas analógicas\n    const analogResult = this._calculateAnalogVirtualValues(\n      sample as AnalogInput[],\n      ts,\n      conf,\n      virtualValueDefinitions,\n    );\n    // Junta los resultados y los devuelve\n    result.push(...analogResult);\n    return result;\n  }\n}\n```","x":-1460,"y":-120,"width":702,"height":240}
	],
	"edges":[
		{"id":"64530af76c184ebb","fromNode":"5d444fb624308fbf","fromSide":"right","toNode":"2e111d782191e0dc","toSide":"left","label":"VirtualValueStrategy"},
		{"id":"2f287001e1e9933e","fromNode":"5d444fb624308fbf","fromSide":"right","toNode":"7ce54f0fb582f936","toSide":"left","label":"Record type"},
		{"id":"bb845171ce6bf46c","fromNode":"75163d2b0255524f","fromSide":"bottom","toNode":"5d444fb624308fbf","toSide":"top"},
		{"id":"33631b96075d25c3","fromNode":"75163d2b0255524f","fromSide":"left","toNode":"795185c8b0afafd9","toSide":"right","label":"Ejemplo con common"},
		{"id":"c969c71b2e8c9ea9","fromNode":"795185c8b0afafd9","fromSide":"bottom","toNode":"36f6083b966fc2a1","toSide":"top","label":"CommonVirtualValueStrategy"}
	]
}