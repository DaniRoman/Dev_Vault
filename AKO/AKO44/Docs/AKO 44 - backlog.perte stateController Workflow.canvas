{
	"nodes":[
		{"id":"f761db1801216c85","type":"text","text":"Define un microservicio llamado `statecontroller.12830`. Prepara un sistema de logs y dos “motores” internos: uno para gestionar configuraciones/backlog y otro para auditoría. Esos motores no se crean al instante, se crean cuando se necesiten.\n\n```js\nclass StateController extends Microservice {\n  // Nombre del servicio (normalmente se usa para logs y trazabilidad)\n  private _serviceName: string = \"statecontroller.12830\";\n  // Logger del servicio\n  protected logger: LoggerHelper;\n  // Componente que procesará la lógica de “backlog” (nuevas configuraciones, estados, etc.)\n  // Empieza a null y se inicializa cuando haga falta.\n  private backlogProcessor: BacklogProcessor | null = null;\n  // Componente que procesará auditorías (registro de cambios).\n  // También se inicializa bajo demanda.\n  private auditProcessor: AuditProcessor | null = null;\n  constructor() {\n    // Inicializa la clase base Microservice (configuración, conexiones, etc.)\n    super(__dirname);\n    // Crea el logger con el nombre del servicio.\n    this.logger = new LoggerHelper(this._serviceName);\n  }\n}\n```","x":-595,"y":-395,"width":727,"height":321},
		{"id":"1a3d9a52af5ed3d3","type":"text","text":"Cuando llega un mensaje de “nueva configuración”, primero prepara el procesador interno. Luego intenta convertir el mensaje (texto) a un objeto. Si el mensaje está mal formado, lo registra y lo ignora.\n\n```js\npublic async handleNewConfiguration(msg: string): Promise<void> {\n  // Se asegura de que el \"BacklogProcessor\" esté listo antes de procesar el mensaje.\n  // (Si no existe, lo crea con sus repositorios y dependencias.)\n  this.initializeBacklogProcessor();\n  // Aquí guardará el mensaje ya convertido de texto a objeto.\n  let parsedMsg: Object | null = null;\n  try {\n    // Intenta convertir el string recibido (msg) a un objeto.\n    parsedMsg = JSON.parse(msg);\n  } catch (error) {\n    // Si msg no es un JSON válido, lo registra como error y abandona.\n    this.logger.error(\"Failed to parse message: \" + error.message);\n    return Promise.resolve();\n  }\n}\n```","x":-595,"y":80,"width":727,"height":321},
		{"id":"2cef0f22f5e95cef","type":"text","text":"Esta función prepara el “motor” que va a gestionar nuevas configuraciones. Si todavía no existe, crea los accesos a base de datos (backlog, dispositivo, definición y auditoría) y con eso construye el `BacklogProcessor`. Si ya estaba creado, no hace nada.\n\n```js\nprivate initializeBacklogProcessor(): void {\n  // Asegura que el procesador de auditoría esté listo antes,\n  // porque el procesamiento de backlog probablemente genera/usa auditorías.\n  this.initializeAuditProcessor();\n  // Si todavía no existe backlogProcessor, lo crea (solo una vez).\n  if (!this.backlogProcessor) {\n    this.logger.info(\"Initializing BacklogProcessor...\");\n    // Modelo + repositorio para leer/escribir en la colección de backlogs.\n    const backlogModel: Model<BacklogModel> = this.getModel(\"backlog\");\n    const backlogRepository = new BacklogRepository(backlogModel);\n    // Modelo + repositorio para consultar/actualizar dispositivos.\n    const deviceModel: Model<DeviceModel> = this.getModel(\"device\");\n    const deviceRepository = new DeviceRepository(deviceModel);\n    // Modelo + repositorio para consultar la definición del dispositivo\n    // (parámetros válidos, rangos, origen device/cloud, etc.).\n    const deviceDefinitionModel: Model<DeviceDefinitionModel> =\n      this.getModel(\"deviceDefinition\");\n    const deviceDefinitionRepository = new DeviceDefinitionRepository(\n      deviceDefinitionModel\n    );\n    // Modelo + repositorio para registrar auditorías (histórico de cambios).\n    const auditModel: Model<AuditModel> = this.getModel(\"audit\");\n    const auditRepository = new AuditRepository(auditModel);\n    // Crea el procesador principal de “nueva configuración” con todo lo necesario.\n    this.backlogProcessor = new BacklogProcessor(\n      backlogRepository,\n      deviceRepository,\n      deviceDefinitionRepository,\n      auditRepository,\n      this.logger\n    );\n    // Log de confirmación.\n    this.logger.info(\"BacklogProcessor initialized successfully.\");\n  }\n}\n```","x":460,"y":80,"width":727,"height":321},
		{"id":"30d17b431962e6c5","type":"text","text":"Verifica que lo recibido sea un objeto, que tenga los campos básicos (`device`, `user`, `timestamp`, `config`) y que `config` sea una lista. Si falta algo o `config` no es lista, lo marca como inválido.\n\n```js\nprivate isValidBacklogMessage(msg: unknown): msg is BacklogMessage {\n  if (!msg || typeof msg !== \"object\") {\n    return false;\n  }\n  const requiredFields = [\"device\", \"user\", \"timestamp\", \"config\"];\n  for (const field of requiredFields) {\n    if (!(field in msg)) {\n      this.logger.error(`Missing required field: ${field}`);\n      return false;\n    }\n  }\n  if (!Array.isArray((msg as BacklogMessage).config)) {\n    return false;\n  }\n  return true;\n}\n```","x":460,"y":540,"width":727,"height":321},
		{"id":"fbcb79c556361af4","type":"text","text":"\nComprueba si el mensaje tiene el formato correcto. Si no lo tiene, lo registra como error y corta el proceso. Si sí lo tiene, lo convierte al tipo esperado y escribe en el log la configuración que va a procesar.\n```js\n// Si el mensaje parseado NO cumple el formato esperado de BacklogMessage,\n// lo registra y corta el procesamiento con error.\nif (!this.isValidBacklogMessage(parsedMsg)) {\n  this.logger.error(\n    \"Invalid backlog message received :: \" + JSON.stringify(parsedMsg)\n  );\n  return Promise.reject(new Error(\"Invalid backlog message\"));\n}\n// A partir de aquí, ya se asume que parsedMsg tiene la forma correcta.\nconst backlogMessage: BacklogMessage = parsedMsg;\n// Log: muestra la parte importante que se va a procesar (la lista de cambios config).\nthis.logger.info(\n  \"Processing valid backlog message with <config>: \" +\n    JSON.stringify(backlogMessage.config)\n);\n```","x":-595,"y":540,"width":727,"height":321},
		{"id":"ed9d1759fb856c68","type":"text","text":"\nIntenta procesar el backlog con `BacklogProcessor`. Si sale un resultado, lo registra y publica un evento `driver.output.12830` con el dispositivo y el resultado para que el siguiente componente lo use. Si no hay resultado, lo deja en log. Si ocurre un error, lo registra y termina sin tumbar el micro.\n```js\ntry {\n  // Ejecuta la lógica principal que procesa el mensaje de backlog\n  // (normalmente: guardar backlog, preparar comandos, actualizar estados, etc.)\n  const processOutput = await this.backlogProcessor.processBacklogMessage(\n    backlogMessage\n  );\n  // Si el procesador devuelve algo (resultado), se considera que hubo trabajo real\n  if (processOutput) {\n    this.logger.info(\n      \"Backlog message processed successfully: \" +\n        JSON.stringify(processOutput)\n    );\n    // Publica un evento de salida para el “driver” con:\n    // - información mínima del dispositivo\n    // - el resultado del procesamiento\n    this.sendEvent(\"driver.output.12830\", {\n      backlogMessage: { device: (backlogMessage as BacklogMessage).device },\n      processOutput,\n    });\n  } else {\n    // Si no devuelve nada, no hubo nada que hacer/procesar\n    this.logger.info(\"No backlog message processed.\");\n  }\n} catch (error) {\n  // Si falla el procesamiento, lo registra y NO rompe el servicio: simplemente termina\n  this.logger.error(\"Failed to process backlog message: \" + error.message);\n  return Promise.resolve();\n}\n// Finaliza el handler\nreturn Promise.resolve();\n\n```","x":-595,"y":1020,"width":727,"height":321},
		{"id":"d59d8a1dc97ff1a2","type":"text","text":"Recibe una lista de cambios para un dispositivo. Si ya existe una “lista pendiente” para ese dispositivo, la actualiza con los nuevos cambios. Si no existe, crea una nueva. Al final devuelve cuáles cambios quedaron pendientes para aplicar.\n```js\npublic async processBacklogMessage(\n  backlogMessage: BacklogMessage\n): Promise<Object | null> {\n  // Saca los campos principales del mensaje\n  const { device, user, timestamp, config } = backlogMessage;\n  // Log: indica para qué dispositivo se está procesando el backlog\n  this.logger.log(\n    LogLevels.INFO,\n    `Processing backlog message for device: ${device._id}`\n  );\n  // Busca si ya existe un backlog \"pending\" (pendiente) para ese dispositivo\n  const existingBacklog = await this.backlogRepository.getLastBacklog(\n    device._id,\n    \"pending\"\n  );\n  // Variable donde guardará el backlog final (actualizado o nuevo)\n  let backlog: Backlog | null = null;\n  // Si hay un backlog pendiente, lo actualiza en vez de crear uno nuevo\n  if (existingBacklog && existingBacklog.status === \"pending\") {\n    this.logger.log(\n      LogLevels.INFO,\n      `Pending backlog found for device ${device._id}. Updating...`\n    );\n    // Mezcla/añade los cambios del mensaje (config) dentro del backlog existente\n    await this.updateBacklog(existingBacklog, config, user);\n    // Vuelve a leer el backlog desde BD para tener la versión actualizada\n    backlog = await this.backlogRepository.getById(existingBacklog._id);\n  } else {\n    // Si no hay backlog pendiente, crea uno nuevo\n    this.logger.log(\n      LogLevels.INFO,\n      `No pending backlog found for device ${device._id}. Creating new...`\n    );\n    //Carga el device “completo” desde BD (no solo el mini device del mensaje)\n    const _device = await this.deviceRepository.getByParameter(\n      \"_id\",\n      device._id,\n      null\n    );\n    // Crea el backlog con esos cambios\n    await this.createBacklog(_device, user, timestamp, config);\n    // Recupera el backlog pendiente recién creado\n    backlog = await this.backlogRepository.getLastBacklog(\n      device._id,\n      \"pending\"\n    );\n  }\n  // Si hay backlog, devuelve SOLO los items que siguen en estado \"pending\"\n  if (backlog) {\n    const pendingItems = backlog.config.filter(\n      (item: Change) => item.status === \"pending\"\n    );\n    // Devuelve un objeto con la lista de cambios pendientes\n    return { pendingItems };\n  }\n  // Si no se pudo obtener/crear backlog, devuelve null\n  return null;\n}\n```","x":460,"y":1020,"width":727,"height":321},
		{"id":"71575f4e48c180e9","type":"text","text":"Si ya había una lista de cambios pendiente para el dispositivo, esta función la “mezcla” con los cambios nuevos: actualiza los que ya existían (solo si siguen pendientes) y añade los que son nuevos. Luego guarda todo de nuevo en la base de datos.\n```js\nprivate async updateBacklog(\n  existingBacklog: Backlog,\n  config: Change[],\n  user: string\n): Promise<void> {\n  // Recorre la configuración ya existente en el backlog\n  // y, si llega un cambio nuevo con la misma \"ref\" y el item existente sigue \"pending\",\n  // actualiza solo el valor nuevo (newValue).\n  const updatedConfig = existingBacklog.config.map((existingConfig) => {\n    // Busca si en el nuevo \"config\" viene un item con la misma ref\n    const newConfigItem = config.find(\n      (item) => item.ref === existingConfig.ref\n    );\n    // Solo actualiza si:\n    // - existe item nuevo\n    // - el item actual del backlog sigue pendiente (pending)\n    if (newConfigItem && existingConfig.status === \"pending\") {\n      this.logger.log(\n        LogLevels.DEBUG,\n        `Updating existing config item with ref: ${existingConfig.ref}`\n      );\n      // Mantiene todo lo que ya había, pero sustituye el newValue\n      return {\n        ...existingConfig,\n        newValue: newConfigItem.newValue,\n      };\n    }\n    // Si no hay item nuevo o ya no está pending, lo deja igual\n    return existingConfig;\n  });\n  // Saca los items nuevos que no existían antes en el backlog (ref que no estaba).\n  const newConfigItems = config.filter(\n    (item) =>\n      !existingBacklog.config.some((existing) => existing.ref === item.ref)\n  );\n  // Persiste el backlog actualizado:\n  // - actualiza user\n  // - marca fecha de actualización\n  // - guarda config como: (lo que ya existía actualizado) + (los items totalmente nuevos)\n  const updatedBacklog = await this.backlogRepository.update(\n    existingBacklog._id,\n    {\n      user,\n      updatedAtGMT: new Date(),\n      config: [...updatedConfig, ...newConfigItems],\n    }\n  );\n  // Log de éxito si se actualizó en BD\n  if (updatedBacklog) {\n    this.logger.log(\n      LogLevels.INFO,\n      `Backlog updated successfully for device ${existingBacklog.device}`\n    );\n  }\n}\n```","x":1540,"y":1020,"width":727,"height":321},
		{"id":"aff577cdfbf37a31","type":"text","text":"Crea una “nueva lista de cambios pendiente” para un dispositivo, la guarda en la base de datos con estado _pending_ y deja un log con lo que creó.\n```js\nprivate async createBacklog(\n  device: Device,\n  user: string,\n  timestamp: number,\n  config: Change[]\n): Promise<void> {\n  // Construye el objeto backlog “nuevo” que se guardará en base de datos\n  const newBacklog: Partial<Backlog> = {\n    device: device._id,                 // id del dispositivo\n    user,                               // usuario que pidió el cambio\n    // Momento en el que “se debe enviar” (ojo: depende de si timestamp está en ms o s)\n    sendAt: new Date(timestamp),\n    sendAtGMT: new Date(timestamp),\n    status: \"pending\",                  // backlog pendiente\n    _company: device._company,          // empresa asociada al dispositivo\n    // Clona la config para evitar referencias/objetos mutables\n    config: JSON.parse(JSON.stringify(config)),\n    // Fechas internas de creación/actualización (en GMT)\n    createdAtGMT: new Date(),\n    updatedAtGMT: new Date(),\n  };\n  // Log: muestra el backlog que va a crear\n  this.logger.log(\n    LogLevels.INFO,\n    `Creating new backlog for device ${\n      device._id\n    }... newBacklog: ${JSON.stringify(newBacklog)}`\n  );\n  // Inserta el backlog en base de datos\n  const createdBacklog = await this.backlogRepository.create(newBacklog);\n  // Log si la creación tuvo éxito\n  if (createdBacklog) {\n    this.logger.log(\n      LogLevels.INFO,\n      `Backlog created successfully for device ${device._id}`\n    );\n  }\n}\n```","x":1540,"y":1500,"width":727,"height":321}
	],
	"edges":[
		{"id":"ec40c1e02672600f","fromNode":"1a3d9a52af5ed3d3","fromSide":"right","toNode":"2cef0f22f5e95cef","toSide":"left","label":"initializeBacklogProcessor"},
		{"id":"1ee4c43e73479ce2","fromNode":"f761db1801216c85","fromSide":"bottom","toNode":"1a3d9a52af5ed3d3","toSide":"top","label":"handleNewConfiguration"},
		{"id":"ced9c93bd767dc0c","fromNode":"1a3d9a52af5ed3d3","fromSide":"bottom","toNode":"fbcb79c556361af4","toSide":"top","label":"handleNewConfiguration"},
		{"id":"b502d339974ef5f2","fromNode":"fbcb79c556361af4","fromSide":"right","toNode":"30d17b431962e6c5","toSide":"left","label":"isValidBacklogMessage"},
		{"id":"aef034133106d480","fromNode":"fbcb79c556361af4","fromSide":"bottom","toNode":"ed9d1759fb856c68","toSide":"top"},
		{"id":"0daf749576cc89b1","fromNode":"ed9d1759fb856c68","fromSide":"right","toNode":"d59d8a1dc97ff1a2","toSide":"left","label":"processBacklogMessage"},
		{"id":"2555e330311327da","fromNode":"d59d8a1dc97ff1a2","fromSide":"right","toNode":"71575f4e48c180e9","toSide":"left","label":"updateBacklog"},
		{"id":"5685cb8a30b8b53a","fromNode":"d59d8a1dc97ff1a2","fromSide":"right","toNode":"aff577cdfbf37a31","toSide":"left","label":"createBacklog"}
	]
}