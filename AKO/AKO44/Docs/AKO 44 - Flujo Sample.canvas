{
	"nodes":[
		{"id":"b51251361bbd01f8","type":"text","text":"","x":-401,"y":-614,"width":250,"height":66},
		{"id":"e952ae4e2cb22e74","type":"text","text":">[!example] Conceptos\n\n***virtual values***: Valores calculados a partir de una fórmula/regla, no del sensor tal cual\n- Cada `VirtualValueDefinition` tiene un campo **`ref`** (referencia/código), que es básicamente el **identificador** del virtual value a calcular.","x":-401,"y":-460,"width":701,"height":260},
		{"id":"32f180a756baf71f","type":"text","text":"Al arrancar el micro, se deja preparado el sistema para calcular valores derivados (virtual values) en función del tipo de dispositivo, y también el parser que convertirá las lecturas entrantes a un formato interno consistente. \n```js\nclass InjectorMicro extends Microservice {\n  // ...\n\n  // Crea un “selector” de estrategias para calcular valores virtuales (derivados).\n  // Aquí solo se registra una estrategia: la común.\n  this.virtualStrategyFactory = new VirtualValueStrategyFactory([\n    new CommonVirtualValueStrategy(),\n  ]);\n\n  // Crea el componente que se encargará de adaptar/normalizar las lecturas\n  // (samples) al formato que el micro usa para guardarlas o procesarlas.\n  this.valueStorageParser = new ValueStorageParser();\n}\n```","x":-401,"y":-140,"width":701,"height":300},
		{"id":"1444b3b39a7e9cab","type":"text","text":"Esta función recibe un mensaje con varios samples en formato JSON, lo parsea y extrae el array de muestras. Luego recorre cada muestra y la convierte en un mensaje individual manteniendo la información del dispositivo. Llama a `processSample()` para procesarlas una a una. Si una muestra falla, lo loguea y continúa con las demás sin parar el procesamiento.\n\n```js\n// Recibe un mensaje (string) que contiene uno o varios samples\npublic async handleSampleInput(msg: string): Promise<any> {\n  this.log(LogLevels.INFO, \"input sample :: \" + msg);\n\n  let sampleMessage: TlOutgoingMessage<NSamplesPayload> = null;\n\n  // Intenta convertir el string JSON a objeto\n  try {\n    sampleMessage = JSON.parse(msg);\n  } catch (error) {\n    // Si no es JSON válido, lo registra y termina sin romper el micro\n    this.log(LogLevels.ERROR, \"Failed to parse message :: \" + error);\n    return Promise.resolve();\n  }\n\n  // Extrae el array de samples del payload\n  const samplesArray = sampleMessage.parsedData.samples;\n\n  // Procesa cada sample individualmente (uno por uno)\n  for (const singleSample of samplesArray) {\n    try {\n      // Crea un mensaje “unitario” reutilizando la info del dispositivo,\n      // pero dejando parsedData con el sample concreto\n      const singleSampleMessage: TlOutgoingMessage<SamplePayload> = {\n        deviceInformation: sampleMessage.deviceInformation,\n        parsedData: singleSample,\n        deviceType: sampleMessage.deviceType\n      };\n\n      // Llama al procesamiento principal de un sample\n      await this.processSample(singleSampleMessage);\n    } catch (error) {\n      // Si falla un sample, lo registra pero sigue con el resto\n      this.log(\n        LogLevels.ERROR,\n        `Failed to process sample [${singleSample.ts}] :: ` + error\n      );\n    }\n  }\n}\n```","x":-401,"y":240,"width":701,"height":320},
		{"id":"4c04b6cd693ba3df","type":"text","text":"![[Pasted image 20260224112144.png]]","x":-1000,"y":220,"width":334,"height":152},
		{"id":"b0b2c32972aa46b5","type":"text","text":"![[Pasted image 20260224112304.png]]","x":-1000,"y":496,"width":334,"height":88},
		{"id":"e06f237836fbd1b7","type":"text","text":"Esta función prepara el entorno (repos/parsers) si aún no está inicializado. Luego carga de base de datos la configuración del dispositivo para poder procesar correctamente el sample. Selecciona la estrategia de cálculo de valores virtuales según el `deviceType`. Después procesa por separado entradas digitales y analógicas, y en las analógicas pasa también la estrategia y la `conf`. Si algo falla en una parte, se loguea el error pero el flujo continúa sin tumbar el micro.\n\n```js\nprivate async processSample(sampleMessage: TlOutgoingMessage<SamplePayload>): Promise<void> {\n  // Si aún no están listos los repos/parsers, los inicializa la primera vez\n  if (!this.deviceRepository || !this.companyRepository || !this.mqInputTimestreamParser) {\n    this.log(LogLevels.INFO, \"Initializing variables...\");\n    await this._intializeVariables();\n  }\n\n  try {\n    // Carga la configuración del dispositivo (conf) desde BD usando el _id del device\n    const deviceConf = await this.deviceRepository.getByParameter(\n      \"_id\",\n      sampleMessage.deviceInformation.device._id,\n      null\n    );\n\n    // Si no hay configuración, no puede procesar (falta conf para cálculos/validaciones)\n    if (!deviceConf) {\n      this.log(LogLevels.ERROR, \"Failed to get device configuration :: \" + sampleMessage.deviceInformation.device._id);\n      return Promise.resolve();\n    }\n\n    // Elige la estrategia de “virtual values” según el tipo de dispositivo\n    const strategy = this.virtualStrategyFactory.getStrategy(\n      sampleMessage.deviceType as DeviceType\n    );\n\n    // Procesa entradas digitales (si fallan, lo registra pero sigue)\n    try {\n      await this._handleDigitalInputs(\n        sampleMessage.deviceInformation,\n        sampleMessage.parsedData.ts,\n        sampleMessage.parsedData.digitalInputs\n      );\n    } catch (error) {\n      this.log(LogLevels.ERROR, \"Failed to handle digital inputs :: \" + error);\n    }\n\n    // Procesa entradas analógicas (pasándole la estrategia + la conf del dispositivo)\n    try {\n      await this._handleAnalogInputs(\n        sampleMessage.deviceInformation,\n        sampleMessage.parsedData.ts,\n        sampleMessage.parsedData.analogInputs,\n        strategy,\n        deviceConf.conf as Record<string, string | number>\n      );\n    } catch (error) {\n      this.log(LogLevels.ERROR, \"Failed to handle analog inputs :: \" + error);\n    }\n\n    return Promise.resolve();\n  } catch (error) {\n    // Si falla el acceso a BD u otra cosa global, lo registra y termina\n    this.log(LogLevels.ERROR, \"Failed to get device configuration :: \" + error);\n    return Promise.resolve();\n  }\n}\n```","x":520,"y":240,"width":701,"height":320},
		{"id":"93ac448f407f259c","type":"text","text":"Esta función procesa las entradas analógicas en dos pasos. Primero, si existe una estrategia para ese dispositivo, calcula “virtual values” usando las lecturas + la configuración y las definiciones del modelo, y los publica por el canal `sample.virtual.inject.perte`. Después, siempre procesa las lecturas analógicas reales: las normaliza con `valueStorageParser`, las convierte a `MiimetiqInputTimestream` y las publica por `sample.inject.perte`. Si no hay estrategia, solo se envían los valores reales. Si algo falla, se loguea y se corta esa parte.\n\n```js\nprivate async _handleAnalogInputs(\n  deviceInfo: TlOutgoingMessage<SamplePayload>[\"deviceInformation\"],\n  timestamp: Date,\n  analoglInputs: AnalogInput[],\n  strategy: VirtualValueStrategy,\n  conf: Record<string, string | number>\n) {\n\n  // 1) Si hay estrategia, primero calcula “virtual values” a partir de las entradas analógicas\n  if (strategy) {\n    try {\n      // Lee qué virtual values hay que calcular para este modelo\n      const virtualValueDefinitions =\n        await this.virtualValueDefinitionReader.getVirtualValueDefinitions(deviceInfo.device.model);\n\n      this.log(LogLevels.DEBUG, \"virtualValueDefinitions:\" + JSON.stringify(virtualValueDefinitions));\n\n      // Calcula los virtual values usando el sample + conf + definiciones\n      const virtualValues = strategy.calculateVirtualValues(\n        analoglInputs,\n        false,\n        timestamp,\n        conf,\n        virtualValueDefinitions\n      );\n\n      // Si no hay virtuals, avisa (pero sigue con los valores reales)\n      if (!virtualValues || virtualValues.length === 0) {\n        this.log(LogLevels.WARN, \"No virtual values calculated for analog inputs\");\n        Promise.resolve(); // (nota: aquí no hace return, solo “pasa”)\n      }\n\n      // Convierte los virtual values al formato interno y los publica por un canal separado\n      const miimetiqInputTimestreamVirtual: MiimetiqInputTimestream =\n        await this.mqInputTimestreamParser.parseMessage(deviceInfo, virtualValues);\n\n      if (!miimetiqInputTimestreamVirtual) {\n        this.log(LogLevels.ERROR, \"Failed to parse message into MiimetiqInputTimestream\");\n        return;\n      }\n\n      this.log(LogLevels.INFO, \"miimetiqInputTimestreamVirtual:  parsed OK\");\n      this.sendEvent(\"sample.virtual.inject.perte\", miimetiqInputTimestreamVirtual);\n\n    } catch (error) {\n      this.log(LogLevels.ERROR, \"Failed to handle virtual values for analog inputs :: \" + error);\n    }\n  } else {\n    // Si no hay estrategia para ese deviceType/modelo, no calcula virtuals\n    this.log(LogLevels.WARN, \"No strategy found for device model: \" + deviceInfo.device.model);\n  }\n\n  // 2) Independientemente de los virtuals, procesa y publica las entradas analógicas “reales”\n  try {\n    // Normaliza/adapta las entradas analógicas al formato de almacenamiento\n    const parsedValues = await this.valueStorageParser.parseAnalogInputs(analoglInputs, timestamp);\n\n    if (parsedValues) {\n      // Convierte a formato interno y lo publica al canal normal de samples\n      const miimetiqInputTimestream: MiimetiqInputTimestream =\n        await this.mqInputTimestreamParser.parseMessage(deviceInfo, parsedValues);\n\n      if (!miimetiqInputTimestream) {\n        this.log(LogLevels.ERROR, \"Failed to parse message into MiimetiqInputTimestream\");\n        Promise.resolve(); // (nota: aquí tampoco hace return)\n      }\n\n      this.sendEvent(\"sample.inject.perte\", miimetiqInputTimestream);\n    }\n  } catch (error) {\n    this.log(LogLevels.ERROR, \"Failed to parse analog inputs :: \" + error);\n    return Promise.resolve();\n  }\n}\n```","x":1440,"y":640,"width":701,"height":320},
		{"id":"f101ad7fd164bea8","type":"text","text":"Toma las entradas digitales del sample y las “parte/agrupa” en el formato que el sistema espera. Luego las transforma a un objeto interno (`MiimetiqInputTimestream`) usando un parser. Si todo va bien, publica ese resultado a Rabbit/bus interno con el evento `sample.inject.perte` para que continúe el flujo. Si algo falla, lo loguea y no envía nada.\n\n```js\nprivate async _handleDigitalInputs(  \ndeviceInfo: TlOutgoingMessage<SamplePayload>[\"deviceInformation\"],  \ntimestamp: Date,  \ndigitalInputs: DigitalInput[]  \n) {  \ntry {  \n// Divide/agrupa las entradas digitales en “bloques” listos para almacenar/procesar  \nconst splittedDigitalInputs = await this.sampleSplitterService.splitDigitalInputs(  \ndigitalInputs,  \ntimestamp,  \ndeviceInfo.device._id  \n);  \n  \n// Si hay datos digitales después de “split”, continúa  \nif (splittedDigitalInputs && splittedDigitalInputs.length > 0) {  \n  \n// Convierte el mensaje a un formato interno (MiimetiqInputTimestream) para enviarlo/almacenarlo  \nconst miimetiqInputTimestream: MiimetiqInputTimestream =  \nawait this.mqInputTimestreamParser.parseMessage(deviceInfo, splittedDigitalInputs);  \n  \n// Si el parser no devuelve nada, corta aquí  \nif (!miimetiqInputTimestream) {  \nthis.log(LogLevels.ERROR, \"Failed to parse message into MiimetiqInputTimestream\");  \nreturn;  \n}  \n  \nthis.log(LogLevels.DEBUG, \"miimetiqInputTimestream: parsed OK\");  \n  \n// Publica el resultado al bus interno (evento/cola) para que lo consuma el siguiente micro/pipeline  \nthis.sendEvent(\"sample.inject.perte\", miimetiqInputTimestream);  \n}  \n} catch (error) {  \n// Si algo falla en el split/parse, lo registra  \nthis.log(LogLevels.ERROR, \"Failed to split digital inputs :: \" + error);  \n}  \n}\n```","x":1440,"y":-140,"width":701,"height":320},
		{"id":"249eb5c474b2a846","x":469,"y":-426,"width":250,"height":60,"type":"text","text":"Este micro recibe mensajes de **samples** ya normalizados y los procesa uno a uno. Primero intenta parsear el JSON y, si viene un lote de muestras, lo divide en mensajes individuales para tratarlos por separado. Para cada muestra, carga de base de datos la **configuración del dispositivo** (conf) y se asegura de tener inicializados los repositorios y parsers necesarios. Luego procesa por un lado las **entradas digitales**, las prepara y las transforma al formato interno (`MiimetiqInputTimestream`) para publicarlas en el canal `sample.inject.perte`. Por otro lado procesa las **entradas analógicas**: calcula valores derivados (“virtual values”) si existe una estrategia para ese tipo/modelo, y los publica en `sample.virtual.inject.perte`. Además, independientemente de los virtuales, normaliza y publica las lecturas analógicas reales también en `sample.inject.perte`. Si falla una muestra o una parte del procesamiento, lo registra en logs y sigue con el resto sin tumbar el servicio."},
		{"id":"61ddc20e68be8b98","type":"text","text":">[!example] Conceptos\n\nEste micro recibe mensajes de **samples** ya normalizados y los procesa uno a uno. Primero intenta parsear el JSON y, si viene un lote de muestras, lo divide en mensajes individuales para tratarlos por separado. Para cada muestra, carga de base de datos la **configuración del dispositivo** (conf) y se asegura de tener inicializados los repositorios y parsers necesarios. Luego procesa por un lado las **entradas digitales**, las prepara y las transforma al formato interno (`MiimetiqInputTimestream`) para publicarlas en el canal `sample.inject.perte`. Por otro lado procesa las **entradas analógicas**: calcula valores derivados (“virtual values”) si existe una estrategia para ese tipo/modelo, y los publica en `sample.virtual.inject.perte`. Además, independientemente de los virtuales, normaliza y publica las lecturas analógicas reales también en `sample.inject.perte`. Si falla una muestra o una parte del procesamiento, lo registra en logs y sigue con el resto sin tumbar el servicio.","x":35,"y":-133,"width":701,"height":260}
	],
	"edges":[
		{"id":"2ef6fddd1414f6a3","fromNode":"b51251361bbd01f8","fromSide":"bottom","toNode":"e952ae4e2cb22e74","toSide":"top"},
		{"id":"430b9b28377b5a69","fromNode":"e952ae4e2cb22e74","fromSide":"bottom","toNode":"32f180a756baf71f","toSide":"top"},
		{"id":"1dad78c88b2b7402","fromNode":"32f180a756baf71f","fromSide":"bottom","toNode":"1444b3b39a7e9cab","toSide":"top","label":"handleSampleInput"},
		{"id":"b823fb90d4744728","fromNode":"1444b3b39a7e9cab","fromSide":"left","toNode":"4c04b6cd693ba3df","toSide":"right","label":"TlOutgoingMessage"},
		{"id":"d37e34bd4c3b929f","fromNode":"1444b3b39a7e9cab","fromSide":"left","toNode":"b0b2c32972aa46b5","toSide":"right","label":"NSamplesPayload"},
		{"id":"944e2f41490fac3c","fromNode":"1444b3b39a7e9cab","fromSide":"right","toNode":"e06f237836fbd1b7","toSide":"left","label":"processSample"},
		{"id":"50085408dc073720","fromNode":"e06f237836fbd1b7","fromSide":"right","toNode":"f101ad7fd164bea8","toSide":"left","label":"_handleDigitalInputs"},
		{"id":"a8b5d7f1ed0b839b","fromNode":"e06f237836fbd1b7","fromSide":"right","toNode":"93ac448f407f259c","toSide":"left","label":"_handleAnalogInputs"}
	]
}