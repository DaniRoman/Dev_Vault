{
	"nodes":[
		{"id":"5f65a0c6b723bb85","x":-1127,"y":-352,"width":250,"height":60,"type":"text","text":""},
		{"id":"b51251361bbd01f8","type":"text","text":"`sample.perte > injector`","x":-401,"y":-614,"width":250,"height":66},
		{"id":"e952ae4e2cb22e74","type":"text","text":">[!example] Conceptos\n\n***virtual values***: Valores calculados a partir de una fórmula/regla, no del sensor tal cual\n- Cada `VirtualValueDefinition` tiene un campo **`ref`** (referencia/código), que es básicamente el **identificador** del virtual value a calcular.","x":-401,"y":-421,"width":621,"height":221},
		{"id":"32f180a756baf71f","type":"text","text":"Al arrancar el micro, se deja preparado el sistema para calcular valores derivados (virtual values) en función del tipo de dispositivo, y también el parser que convertirá las lecturas entrantes a un formato interno consistente. \n```js\nclass InjectorMicro extends Microservice {\n  // ...\n\n  // Crea un “selector” de estrategias para calcular valores virtuales (derivados).\n  // Aquí solo se registra una estrategia: la común.\n  this.virtualStrategyFactory = new VirtualValueStrategyFactory([\n    new CommonVirtualValueStrategy(),\n  ]);\n\n  // Crea el componente que se encargará de adaptar/normalizar las lecturas\n  // (samples) al formato que el micro usa para guardarlas o procesarlas.\n  this.valueStorageParser = new ValueStorageParser();\n}\n```","x":-401,"y":-140,"width":621,"height":260},
		{"id":"37c3f9d0a3a2a322","type":"text","text":">[!tip] Patron de diseño Factory\n>\n\n[[Arquitectura y diseño#^81cb34]]\n","x":-1200,"y":0,"width":621,"height":120},
		{"id":"a73283042ef2f431","type":"text","text":"Esta clase es básicamente una “agenda”: para cada `deviceType` guarda qué clase sabe calcular sus virtual values. Luego, cuando llega un sample, el micro pide la estrategia del tipo correspondiente y la usa, en vez de hacer `if/else` por cada modelo.\n```js\nexport class VirtualValueStrategyFactory {\n  // Un diccionario: la clave es el tipo de dispositivo y el valor es la “forma de calcular”\n  // los virtual values para ese tipo.\n  private strategies: Partial<Record<DeviceType, VirtualValueStrategy>> = {};\n\n  constructor(strategies: VirtualValueStrategy[]) {\n    // Recibe una lista de estrategias y las registra.\n    // Ejemplo: si una estrategia tiene deviceType = \"12830\",\n    // entonces se guarda en strategies[\"12830\"].\n    for (const s of strategies) {\n      this.strategies[s.deviceType] = s;\n    }\n  }\n\n  // (si está en vuestro código completo)\n  // Devuelve la estrategia para ese tipo de dispositivo.\n  // Nota: si no existe una estrategia para ese tipo, esto puede devolver undefined.\n  // getStrategy(deviceType: DeviceType): VirtualValueStrategy | undefined {\n  //   return this.strategies[deviceType];\n  // }\n}\n```","x":600,"y":-140,"width":621,"height":260},
		{"id":"de0e7932e262c4d7","type":"text","text":"Esta estrategia define las reglas “comunes” para un tipo de dispositivo concreto (`12830`). Declara qué referencias del sample y qué parámetros de configuración necesita para calcular virtual values (por ejemplo, TTI “above/in/bellow” usando la sonda `prb1`, el setpoint actual y un delta). El mapa `ttiValuesMap` actúa como una tabla de “cálculo”: según el `ref` virtual que piden, indica de dónde sacar los datos para poder calcularlo.\n\n```js\nexport class CommonVirtualValueStrategy implements VirtualValueStrategy {\n  // Identifica para qué tipo de dispositivo sirve esta estrategia.\n  readonly deviceType = \"12830\";\n\n  private logger = new LoggerHelper(\"CommonVirtualValueStrategy\");\n\n  // Referencias (refs) que se usan en los cálculos:\n  // - setpoint actual (del sample)\n  // - delta configurado (de la conf)\n  // - límites de alarma (de la conf)\n  private static readonly PARAM_SETPOINT = \"reg_amv_analog_actual_sp\";\n  private static readonly PARAM_DELTA = \"param_C1_sp_delta\";\n  private static readonly PARAM_ALARM_MAX = \"param_A1_alarm_prb1_max\";\n  private static readonly PARAM_ALARM_MIN = \"param_A2_alarm_prb1_min\";\n\n  // Mapa que relaciona “qué virtual value quiero calcular” → “qué entradas necesito”.\n  // Para cada ref virtual (tti_above/tti_bellow/tti_in) dice:\n  // - qué ref del sample usar como valor principal (sonda prb1)\n  // - qué ref usar como setpoint\n  // - qué parámetro usar como delta\n  private static readonly ttiValuesMap = new Map<string, TtiValueConfig>([\n    [\n      \"reg_cloud_virtual_value_tti_above\",\n      {\n        setpoint: CommonVirtualValueStrategy.PARAM_SETPOINT,\n        delta: CommonVirtualValueStrategy.PARAM_DELTA,\n        ref: \"reg_amv_analog_prb1\",\n      },\n    ],\n    [\n      \"reg_cloud_virtual_value_tti_bellow\",\n      {\n        setpoint: CommonVirtualValueStrategy.PARAM_SETPOINT,\n        delta: CommonVirtualValueStrategy.PARAM_DELTA,\n        ref: \"reg_amv_analog_prb1\",\n      },\n    ],\n    [\n      \"reg_cloud_virtual_value_tti_in\",\n      {\n        setpoint: CommonVirtualValueStrategy.PARAM_SETPOINT,\n        delta: CommonVirtualValueStrategy.PARAM_DELTA,\n        ref: \"reg_amv_analog_prb1\",\n      },\n    ],\n  ]);\n}\n```","x":760,"y":-520,"width":621,"height":260}
	],
	"edges":[
		{"id":"2ef6fddd1414f6a3","fromNode":"b51251361bbd01f8","fromSide":"bottom","toNode":"e952ae4e2cb22e74","toSide":"top"},
		{"id":"153a0bfd6a5bc54e","fromNode":"32f180a756baf71f","fromSide":"left","toNode":"37c3f9d0a3a2a322","toSide":"top"},
		{"id":"79490febc8a64861","fromNode":"32f180a756baf71f","fromSide":"right","toNode":"a73283042ef2f431","toSide":"left","label":"VirtualValueStrategyFactory"}
	]
}