{
	"nodes":[
		{"id":"b51251361bbd01f8","type":"text","text":"`sample.perte > injector`","x":-401,"y":-614,"width":250,"height":66},
		{"id":"e952ae4e2cb22e74","type":"text","text":">[!example] Conceptos\n\n***virtual values***: Valores calculados a partir de una fórmula/regla, no del sensor tal cual\n- Cada `VirtualValueDefinition` tiene un campo **`ref`** (referencia/código), que es básicamente el **identificador** del virtual value a calcular.","x":-401,"y":-421,"width":621,"height":221},
		{"id":"32f180a756baf71f","type":"text","text":"Al arrancar el micro, se deja preparado el sistema para calcular valores derivados (virtual values) en función del tipo de dispositivo, y también el parser que convertirá las lecturas entrantes a un formato interno consistente. \n```js\nclass InjectorMicro extends Microservice {\n  // ...\n\n  // Crea un “selector” de estrategias para calcular valores virtuales (derivados).\n  // Aquí solo se registra una estrategia: la común.\n  this.virtualStrategyFactory = new VirtualValueStrategyFactory([\n    new CommonVirtualValueStrategy(),\n  ]);\n\n  // Crea el componente que se encargará de adaptar/normalizar las lecturas\n  // (samples) al formato que el micro usa para guardarlas o procesarlas.\n  this.valueStorageParser = new ValueStorageParser();\n}\n```","x":-401,"y":-140,"width":621,"height":260},
		{"id":"1444b3b39a7e9cab","type":"text","text":"Al arrancar el micro, se deja preparado el sistema para calcular valores derivados (virtual values) en función del tipo de dispositivo, y también el parser que convertirá las lecturas entrantes a un formato interno consistente. \n```js\n\n```","x":-1100,"y":-180,"width":621,"height":260}
	],
	"edges":[
		{"id":"2ef6fddd1414f6a3","fromNode":"b51251361bbd01f8","fromSide":"bottom","toNode":"e952ae4e2cb22e74","toSide":"top"},
		{"id":"430b9b28377b5a69","fromNode":"e952ae4e2cb22e74","fromSide":"bottom","toNode":"32f180a756baf71f","toSide":"top"}
	]
}