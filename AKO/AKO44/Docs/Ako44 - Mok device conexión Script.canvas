{
	"nodes":[
		{"id":"6743868b8bcbe7a9","type":"text","text":" _Archivo para mokear la conexión_ [Ver Archivo](vscode://file/Users/daniel.roman/Library/CloudStorage/OneDrive-AKOElectromecanicaSA/Dev/ako44/akocloud-micros/bin/examples/client-perte.js)\n ","x":-1360,"y":-860,"width":660,"height":60},
		{"id":"2f15da48202d1b4a","type":"text","text":"Importaciónes necesarias\n\n![[Pasted image 20260216101119.png]]\n\n**`amqplib`**: Librería de Node para hablar AMQP.\n`AMQP`: Protocolo que usa RabbitMQ (Advanced Message Queuing Protocol).\n***`coap`***: **librería de Node.js** que Implementa el **protocolo CoAP** (Constrained Application Protocol). Es como “el HTTP de IoT”\n- Da las piezas para actuar como **cliente** (y también servidor si quisieras):\n- Construir una petición CoAP (`GET`, `POST`, `PUT`, `DELETE`)\n***`cbor`*** : **CBOR** (Concise Binary Object Representation) es un formato de serialización **binario**\n- Para convertir un objeto JS (tu “Message”) en un **Buffer binario**:\n\t- **encode**: objeto → bytes (Buffer)\n\t- **decode**: bytes → objeto\n- Buffer de bytes: una zona de memoria que guarda datos binarios “crudos” (bytes), no texto ni objetos JS.\n","x":-1360,"y":-700,"width":660,"height":320},
		{"id":"62cfbfa8c535efd7","type":"text","text":"amqp_types aparecera mas abajo para saber bien que hace","x":-1660,"y":120,"width":240,"height":100},
		{"id":"f3e006a82009d4b5","type":"text","text":"![[Pasted image 20260216103224.png]]\n\n`AMQP_TYPES`: comprobar que el mensaje que llega trae un `type` permitido.\n- `cmd`: probablemente “comando” (ejecutar algo o enviar orden a un dispositivo).\n- `live_request`: petición de datos en vivo (telemetría estado actual)\n- `ht_key`\n- \n```json\n{\n  \"type\": \"cmd\",\n  \"payload\": { ... }\n}```","x":-1360,"y":-280,"width":660,"height":240},
		{"id":"e5f9a7081ff33489","type":"text","text":"![[Pasted image 20260216110821.png]]\ndos constantes son **necesarias** como parámetros del cálculo:\n- **`CRC32_INITIAL_VALUE`**: el valor inicial (seed) desde el que arranca el registro CRC.\n- **`POLYNOMIAL`**: el polinomio que define cómo se actualiza el CRC al procesar bits/bytes.","x":-1370,"y":80,"width":680,"height":180},
		{"id":"fad8e67e5190cb6a","type":"text","text":"Esta función decide en qué modo debe funcionar el script (AMQP o CoAP) basándose en los argumentos. Si no puede determinarlo, muestra cómo se usa correctamente y termina. Si sí puede, llama al parser correspondiente para construir una configuración completa. Añade el protocolo detectado a esa configuración. Y si está en modo verbose, lo imprime antes de devolver la configuración.\n\n```js\nfunction parseArgs() {\n  // Intenta deducir el protocolo (AMQP/RabbitMQ o CoAP) mirando los argumentos del CLI\n  const protocol = detectProtocol();\n\n  // Si no puede deducirlo, muestra error + ejemplos de uso y termina el programa\n  if (!protocol) {\n    console.error(\"Error: Could not determine protocol (AMQP or CoAP)\");\n    console.error(\n      \"Usage: node client-perte.js <serial_number> [type] [options] (AMQP)\",\n    );\n    console.error(\n      \"       node client-perte.js <serial_number> <uuid> [type] [options] (CoAP)\",\n    );\n    process.exit(1);\n  }\n\n  // Con el protocolo ya decidido, parsea el resto de argumentos y construye el objeto config\n  const config = parseProtocolArgs(protocol);\n\n  // Añade explícitamente el protocolo al objeto de configuración\n  config.protocol = protocol;\n\n  // Si está activado verbose, imprime el protocolo detectado\n  if (config.verbose) {\n    console.log(\"Protocol:\", config.protocol);\n  }\n\n  // Devuelve la configuración final para que el resto del script la use\n  return config;\n}\n```","x":-740,"y":380,"width":680,"height":400},
		{"id":"59e6c19c03e8871a","type":"text","text":"Esta función intenta adivinar si el script debe funcionar en modo RabbitMQ (AMQP) o en modo CoAP mirando los argumentos que le pasas al ejecutarlo. Si el segundo argumento coincide con un tipo conocido de AMQP, elige AMQP. Si el segundo argumento parece un UUID o un valor hexadecimal, elige CoAP. Además, valida que no se esté pasando un “tipo AMQP” donde no toca en CoAP. Si no puede decidir, devuelve `null`.\n\n```js\nfunction detectProtocol() {\n  // Coge los argumentos que el usuario pasó al script (sin \"node\" ni el nombre del fichero)\n  const args = process.argv.slice(2);\n\n  // Si no hay al menos 2 argumentos \"de usuario\", no puede decidir protocolo\n  if (args.length < 2) {\n    return null;\n  }\n\n  // Segundo argumento posicional (depende del modo: en AMQP suele ser \"type\", en CoAP suele ser \"uuid\")\n  const secondArg = args[1];\n  // Tercer argumento posicional (en CoAP podría ser el \"type\")\n  const thirdArg = args[2];\n\n  // Regla 1: si el segundo argumento coincide con uno de los tipos AMQP conocidos,\n  // asume que el protocolo es AMQP (RabbitMQ)\n  if (AMQP_TYPES.includes(secondArg)) {\n    return \"amqp\";\n  }\n\n  // Regla 2: si el segundo argumento parece un UUID (muy largo) o una cadena hexadecimal (0x...),\n  // asume que es CoAP (porque en CoAP el segundo posicional es el uuid)\n  if (secondArg.startsWith(\"0x\") || secondArg.length > 20) {\n    // Validación extra: si el tercer argumento fuera un tipo AMQP, para CoAP sería un \"type\" inválido\n    // (el script no acepta esos tipos en modo CoAP), así que aborta con error\n    if (AMQP_TYPES.includes(thirdArg)) {\n      console.error(\n        `Error: invalid type argument for CoAP protocol, received '${thirdArg}'`,\n      );\n      process.exit(1);\n    }\n\n    return \"coap\";\n  }\n\n  // Si no encaja en ninguna regla, no sabe qué protocolo es\n  return null;\n}\n\n```","x":200,"y":380,"width":680,"height":400},
		{"id":"5855c64898e04051","type":"text","text":"La función recoge lo que escribes al ejecutar el programa en la terminal y lo convierte en una configuración lista para usar. Según si el programa va a trabajar por RabbitMQ (AMQP) o por CoAP, decide qué datos son obligatorios y cuáles son opcionales. Permite indicar el host, el puerto, un timestamp, activar modo “verbose” y añadir un payload en formato JSON (directo o desde un archivo). También interpreta los primeros parámetros “normales” como identificadores del dispositivo (y en CoAP además un UUID). Si falta algún dato imprescindible, muestra un mensaje de uso correcto y termina el programa con error.\n\n```node\nfunction parseProtocolArgs(protocol) {\n  // Lee argumentos CLI (todo lo que viene después de `node script.js ...`)\n  const args = process.argv.slice(2);\n  //devuelve **una copia del array** empezando en el índice 2\n  \n  //`process.argv[0]` → la ruta al ejecutable `node`\n  //`process.argv[1]` → la ruta al archivo `.js` que estás ejecutando\n  //`process.argv[2...]` → los argumentos “de usuario” que tú escribes\n\n  // Config base común para ambos protocolos\n  const baseConfig = {\n    host: \"localhost\",\n    serialNumber: null,                 // requerido (posicional)\n    type: null,                         // opcional (posicional)\n    timestamp: Math.floor(Date.now() / 1000), // por defecto: epoch seconds “ahora”\n    payload: null,                      // opcional: JSON inline o desde fichero\n    verbose: false,                     // opcional: logs extra\n  };\n\n  // Defaults específicos por protocolo:\n  // - AMQP: puerto 5672 + campos extra (model/user/conf)\n  // - CoAP: puerto 5685 + campo uuid\n  const config =\n    protocol === \"amqp\"\n      ? {\n          ...baseConfig,\n          port: 5672,\n          model: \"unvalued\",\n          user: \"unvalued\",\n          conf: {},\n        }\n      : { ...baseConfig, port: 5685, uuid: null };\n  // Índice para ir asignando argumentos posicionales (los que no empiezan por \"-\")\n  let positionalArgIndex = 0;\n  // Recorre args uno por uno, interpretando flags y posicionales\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    const nextArg = args[i + 1];\n\n    // ===== Opciones comunes =====\n\n    // --host/-h <host>\n    if ((arg === \"--host\" || arg === \"-h\") && nextArg) {\n      config.host = nextArg;\n      i++; // consume el valor\n    }\n    // --port/-p <port>\n    else if ((arg === \"--port\" || arg === \"-p\") && nextArg) {\n      config.port = parseInt(nextArg);\n      i++;\n    }\n    // --timestamp/-ts <epoch_seconds>\n    else if ((arg === \"--timestamp\" || arg === \"-ts\") && nextArg) {\n      config.timestamp = parseInt(nextArg);\n      i++;\n    }\n    // --payload/-pl <json>  o  --payload @archivo.json\n    else if ((arg === \"--payload\" || arg === \"-pl\") && nextArg) {\n      try {\n        // Si empieza por \"@\", interpreta que es un fichero a leer\n        if (nextArg.startsWith(\"@\")) {\n          const filename = nextArg.slice(1);\n          const fileContent = fs.readFileSync(filename, \"utf8\");\n          config.payload = JSON.parse(fileContent);\n        } else {\n          // Si no, interpreta que es JSON inline\n          config.payload = JSON.parse(nextArg);\n        }\n      } catch (e) {\n        // Errores típicos: fichero no existe o JSON inválido\n        if (e.code === \"ENOENT\") {\n          console.error(\"Error: Payload file not found:\", e.path);\n        } else {\n          console.error(\"Error: Invalid JSON payload:\", e.message);\n        }\n        process.exit(1);\n      }\n      i++; // consume el valor\n    }\n    // --verbose/-v (flag sin valor)\n    else if (arg === \"--verbose\" || arg === \"-v\") {\n      config.verbose = true;\n    }\n\n    // ===== Opciones específicas de AMQP =====\n    else if (protocol === \"amqp\") {\n      // --model/-m <model>  (nota: aquí se parsea a int)\n      if ((arg === \"--model\" || arg === \"-m\") && nextArg) {\n        config.model = parseInt(nextArg);\n        i++;\n      }\n      // --user/-u <user> (nota: aquí se parsea a int)\n      else if ((arg === \"--user\" || arg === \"-u\") && nextArg) {\n        config.user = parseInt(nextArg);\n        i++;\n      }\n      // Posicionales AMQP:\n      // 1) serialNumber\n      // 2) type (opcional)\n      else if (!arg.startsWith(\"-\")) {\n        if (positionalArgIndex === 0) {\n          config.serialNumber = arg; // aquí NO se parsea a int (queda string)\n          positionalArgIndex++;\n        } else if (positionalArgIndex === 1) {\n          config.type = arg;\n          positionalArgIndex++;\n        }\n      }\n    }\n\n    // ===== Opciones específicas de CoAP =====\n    else if (protocol === \"coap\") {\n      // Posicionales CoAP:\n      // 1) serialNumber (se parsea a int)\n      // 2) uuid (string)\n      // 3) type (opcional)\n      if (!arg.startsWith(\"-\")) {\n        if (positionalArgIndex === 0) {\n          config.serialNumber = parseInt(arg);\n          positionalArgIndex++;\n        } else if (positionalArgIndex === 1) {\n          config.uuid = arg;\n          positionalArgIndex++;\n        } else if (positionalArgIndex === 2) {\n          config.type = arg;\n          positionalArgIndex++;\n        }\n      }\n    }\n  }\n  // ===== Validación de argumentos requeridos =====\n  // serialNumber siempre es obligatorio\n  if (!config.serialNumber) {\n    console.error(\"Error: Serial Number is required as first argument.\");\n    console.error(\n      protocol === \"amqp\"\n        ? \"Usage: node client-perte.js <serial_number> [type] [options]\"\n        : \"Usage: node client-perte.js <serial_number> <uuid> [type] [options]\",\n    );\n    process.exit(1);\n  }\n\n  // en CoAP, uuid también es obligatorio\n  if (protocol === \"coap\" && !config.uuid) {\n    console.error(\"Error: UUID is required as second argument.\");\n    console.error(\n      \"Usage: node client-perte.js <serial_number> <uuid> [type] [options]\",\n    );\n    process.exit(1);\n  }\n\n  // Devuelve el objeto config final para que el resto del script lo use\n  return config;\n}\n```","x":200,"y":940,"width":680,"height":420},
		{"id":"458c643588f49124","type":"text","text":"![[Pasted image 20260216125617.png]]","x":-1260,"y":436,"width":370,"height":288},
		{"id":"5f7222baac878007","type":"text","text":"Envía un mensaje a un servidor CoAP mediante un POST. El mensaje puede venir de un payload manual o generarse automáticamente según la configuración. Lo codifica en CBOR y le añade un checksum (CRC) para asegurar integridad. Envía el contenido al endpoint construido con el número de serie (y un sufijo especial si el tipo es “link”). Luego imprime la respuesta, decodificándola si viene también en CBOR.\n\n**Detalle importante (para entender el “packaging”):** el body final no es “CBOR puro”: es **CBOR + CRC concatenado** a nivel de bytes (lo hacen convirtiendo a hex, concatenando, y volviendo a bytes). Esto implica que el servidor espera exactamente ese formato.\n\n```js\nasync function runCoAP(config) {\n  let selectedMessage;\n\n  // Si el usuario pasó --payload/-pl, usa ese payload tal cual como mensaje\n  if (config.payload) {\n    selectedMessage = config.payload;\n    if (config.verbose) {\n      console.log(\"Using custom payload\");\n    }\n  } else {\n    // Si no hay payload custom, construye el mensaje según la config (type, serial, timestamp, etc.)\n    // !!!! FUNCION DESGLOSADA !!!-----------------------------------------\n    selectedMessage = createMessage(config);\n\n    // Si el type no es válido para CoAP, aborta mostrando la lista de tipos aceptados\n    if (!selectedMessage) {\n      console.error(\"Invalid message type:\", config.type);\n      console.error(\n        \"Valid types: status, event, alarm, audit, sample, activity, cmd_ack, cmd_ack_error, sync, test,\",\n      );\n      console.error(\n        \"              live_request, live_request_ack, live, hotkey, hotkey_ack, link, param, param_ack,\",\n      );\n      console.error(\"              sch, sch_ack, net, net_ack\");\n      process.exit(1);\n    }\n  }\n\n  // Log básico de destino (servidor CoAP + puerto) y tipo de mensaje\n  console.log(\n    \"CoAP SERVER:\",\n    config.host,\n    \"PORT:\",\n    config.port,\n    \"TYPE:\",\n    config.type,\n  );\n\n  // Construye el path del recurso CoAP:\n  // Siempre empieza por \"/<serialNumber>/sn\"\n  // y si el type es \"link\", añade \"/link\" al final\n  const pathname =\n    `/${config.serialNumber}/sn` + (config.type === \"link\" ? \"/link\" : \"\");\n\n  // En verbose, imprime path y el objeto del mensaje\n  if (config.verbose) {\n    console.log(\"Pathname:\", pathname);\n    console.log(\"Message:\", selectedMessage);\n  }\n\n  // Prepara una petición CoAP tipo POST hacia el recurso indicado\n  // y declara que el body va en CBOR\n  const req = coap.request({\n    host: config.host,\n    port: config.port,\n    pathname: pathname,\n    method: \"POST\",\n    headers: {\n      \"Content-Format\": \"application/cbor\",\n    },\n  });\n\n  // Codifica el objeto JS a CBOR (Buffer)\n  // (la línea comentada era una forma incorrecta/innecesaria: cbor.encode ya devuelve Buffer)\n  const messageBuffer = cbor.encode(selectedMessage);\n\n  // Calcula un CRC (checksum) usando el uuid y el buffer CBOR (integridad del mensaje)\n  const crcForMessage = getCRC(config.uuid, messageBuffer);\n  if (config.verbose) {\n    console.log(\"CRC calculated:\", crcForMessage);\n  }\n\n  // \"Empaqueta\" el mensaje final:\n  // - Convierte el CBOR a hex\n  // - Le concatena el CRC (que parece venir ya como string hexadecimal)\n  const encodeMessage = messageBuffer.toString(\"hex\") + crcForMessage;\n  if (config.verbose) {\n    console.log(\"Encoded message:\", encodeMessage);\n  }\n\n  // Vuelve a convertir ese hex concatenado a bytes reales (Buffer) -> este es el body final del POST\n  const finalMessage = Buffer.from(encodeMessage, \"hex\");\n  if (config.verbose) {\n    console.log(\"Final message buffer:\", finalMessage);\n  }\n\n  console.log(\"Sending CoAP request...\");\n\n  // Envía el body y termina la request\n  req.end(finalMessage);\n\n  // Si hay error de red/envío, lo muestra y aborta\n  req.on(\"error\", function (err) {\n    console.error(\"Error sending CoAP request:\", err.message);\n    process.exit(1);\n  });\n\n  // Al recibir respuesta del servidor CoAP...\n  req.on(\"response\", function (res) {\n    // Si el servidor responde con Content-Format = application/cbor,\n    // decodifica el payload como CBOR y lo imprime\n    if (\n      res.headers &&\n      res.headers[\"Content-Format\"] &&\n      res.headers[\"Content-Format\"] == \"application/cbor\"\n    ) {\n      console.log(\n        \"RESPONSE SERVER (CBOR): \",\n        res.headers,\n        cbor.decode(res.payload),\n      );\n    } else {\n      // Si no es CBOR, imprime el payload tal cual (como JSON stringificado de bytes)\n      console.log(\n        \"RESPONSE SERVER (NO CBOR): \",\n        res.headers,\n        JSON.stringify(res.payload),\n      );\n    }\n    // Termina el proceso con éxito\n    process.exit(0);\n  });\n}\n```","x":-1800,"y":960,"width":680,"height":400},
		{"id":"914a4efb658784a8","type":"text","text":"\n\n```js\nfunction createSampleMessage(config) {\n  // Genera un mensaje de tipo \"sample\" (muestras/telemetría)\n  return {\n    // Identificador compuesto del equipo/mensaje:\n    // [sn, pv, pr, psr, spec] según comentario del autor\n    id: [config.serialNumber, 6000, 1, 26, 0],\n    // Tipo de mensaje\n    ty: \"sample\",\n    // Location ID (instalación/ubicación lógica)\n    li: 1,\n    // Datos \"analógicos\"/sensores:\n    // Cada fila: [ts, s1_v, s1_unit, s1_decimals, s2_v, s2_unit, s2_decimals, ...]\n    d: [\n      // Ejemplo interpretado por el comentario:\n      // temp=22.5°C (225 con 1 decimal, unidad 1), hum=65.0% (650 con 1 decimal, unidad 2), temp2=-5.0°C (-50 con 1 decimal, unidad 1)\n      [config.timestamp, 225, 1, 1, 650, 2, 1, -50, 1, 1],\n      // Segunda muestra 10s después\n      [config.timestamp + 10, 230, 1, 1, 655, 2, 1, -48, 1, 1],\n      // Tercera muestra 20s después\n      [config.timestamp + 20, 228, 1, 1, 652, 2, 1, -49, 1, 1],\n    ],\n    // Datos \"digitales\" + contadores:\n    // Cada fila: [ts, d1_v, d1_c, d2_v, d2_c, ...]\n    d1: [\n      // d1=1 (cnt=150), d2=0 (cnt=75), d3=1 (cnt=200), d4=0 (cnt=100)\n      [config.timestamp, 1, 150, 0, 75, 1, 200, 0, 100],\n      // 10s después: algunos contadores cambian y d4 pasa a 1\n      [config.timestamp + 10, 1, 152, 0, 76, 1, 202, 1, 101],\n      // 20s después: d1 pasa a 0, d2 pasa a 1, etc.\n      [config.timestamp + 20, 0, 153, 1, 77, 1, 204, 1, 103],\n    ],\n  };\n}\n```","x":-3600,"y":520,"width":680,"height":400},
		{"id":"bbf512112efe5f68","type":"text","text":"\n\n```js\nfunction createEventMessage(config) {\n  // Genera un mensaje de tipo \"event\" (eventos puntuales con estado/valor)\n  return {\n    // Identificador compuesto del equipo/mensaje\n    id: [config.serialNumber, 6000, 1, 26, 0],\n    // Tipo de mensaje\n    ty: \"event\",\n    // Datos de eventos:\n    // Cada fila: [ts, event_id, val, st, cnt_id]\n    d: [\n      // event_id=19, val=100, st=1 (ON), cnt_id=1\n      [config.timestamp, 19, 100, 1, 1],\n      // event_id=25, val=50, st=1 (ON), cnt_id=2\n      [config.timestamp + 10, 25, 50, 1, 2],\n      // event_id=30, val=0, st=0 (OFF), cnt_id=3\n      [config.timestamp + 20, 30, 0, 0, 3],\n    ],\n  };\n}\n```","x":-3600,"y":1480,"width":680,"height":400},
		{"id":"85b1d1f10533721c","type":"text","text":"Esta función envía un mensaje a RabbitMQ usando AMQP. Primero decide qué mensaje mandar: uno personalizado (`--payload`) o uno generado automáticamente según la configuración. Luego calcula a qué “destino” (exchange y routing key) debe publicarlo según el tipo. Se conecta al servidor AMQP, se asegura de que el exchange exista y publica el mensaje. Finalmente cierra la conexión y termina el programa.\n\nNo manda a una cola directamente; publica a un **exchange tipo topic** con una **routing key**. Las **colas** recibirán el mensaje si están enlazadas (bind) a ese exchange con una clave/patrón que coincida.\n\n```js\nasync function runAMQP(config) {\n  let selectedMessage;\n\n  // Si el usuario pasó --payload/-pl, usa ese payload tal cual como mensaje\n  if (config.payload) {\n    selectedMessage = config.payload;\n    if (config.verbose) {\n      console.log(\"Using custom payload\");\n    }\n  } else {\n    // Si no hay payload custom, construye el mensaje a partir de la config (serial, type, timestamp, etc.)\n    selectedMessage = createMessage(config);\n\n    // Si createMessage devuelve null/undefined, el type es inválido (no soportado)\n    if (!selectedMessage) {\n      console.error(\"Invalid message type:\", config.type);\n      console.error(`Valid types: ${AMQP_TYPES.join(\", \")}`);\n      process.exit(1);\n    }\n  }\n\n  // En base al type, decide a qué exchange y con qué routing key publicar\n  const exchange = getAmqpExchange(config.type);\n  const routingKey = getAmqpRoutingKey(config.type);\n\n  // Log de “a dónde” va a enviar el mensaje\n  console.log(\n    \"AMQP SERVER\",\n    config.host,\n    \"PORT:\",\n    config.port,\n    \"EXCHANGE:\",\n    exchange,\n    \"ROUTING KEY:\",\n    routingKey,\n    \"TYPE:\",\n    config.type,\n  );\n\n  // En verbose, imprime el contenido del mensaje que va a mandar\n  if (config.verbose) {\n    console.log(\"Message:\", selectedMessage);\n  }\n\n  // Conecta al broker AMQP (normalmente RabbitMQ) usando host y port\n  const connection = await amqp.connect(`amqp://${config.host}:${config.port}`);\n\n  // Crea un canal AMQP (la “sesión” donde publicas/consumes)\n  const channel = await connection.createChannel();\n\n  // Asegura que el exchange exista (si no existe lo crea):\n  // - tipo: \"topic\" (routingKey con patrones)\n  // - durable: true (sobrevive reinicios del broker)\n  await channel.assertExchange(exchange, \"topic\", { durable: true });\n\n  console.log(\"Sending AMQP message...\");\n\n  // Publica el mensaje:\n  // - cuerpo: JSON stringificado -> Buffer\n  // - exchange + routingKey determinan el enrutado hacia colas binded\n  channel.publish(\n    exchange,\n    routingKey,\n    Buffer.from(JSON.stringify(selectedMessage)),\n  );\n\n  // Cierra canal y conexión (este script es de “disparar y salir”)\n  await channel.close();\n  await connection.close();\n\n  console.log(\"Message sent\");\n\n  // Termina el proceso con código 0 (éxito)\n  process.exit(0);\n}\n\n```","x":-960,"y":960,"width":680,"height":400},
		{"id":"e56351d6644c1555","type":"text","text":"Calcula el **CRC32 final** del payload (normalmente CBOR) y lo devuelve como **hex de 8 caracteres**. Importante: no usa una seed fija; primero deriva una seed a partir del `uuid` (con `_nbiot_crc32_init`) y luego calcula el CRC del payload con esa seed.\n\n```js\nfunction getCRC(uuid, payload, crcOrigin = \"\") {\n  const uuidHexPart = uuid.replace(/^0x/, \"\");\n  const crc_ini_val_nbiot = _nbiot_crc32_init(uuidHexPart);\n  const p_buf_payload = Array.from(payload); // payload debe ser Buffer o Uint8Array\n  const crc32 = _calculateCrcWithSeed(\n    crc_ini_val_nbiot,\n    p_buf_payload,\n    p_buf_payload.length,\n  );\n  const finalCrc32ToHex = crc32.toString(16).padStart(8, \"0\");\n  return finalCrc32ToHex;\n}\n\n```","x":-2460,"y":1580,"width":680,"height":400},
		{"id":"a48a38e92b7874ea","type":"text","text":"Devuelve la **routing key** (topic) usada al publicar en el exchange. Esa clave determina cómo RabbitMQ enruta el mensaje hacia las colas bindeadas. Si el tipo no está contemplado, lanza error.\n\n```js\nfunction getAmqpRoutingKey(type) {\n  switch (type) {\n    case \"cmd\":\n      return \"backlog.perte.input\";\n    case \"cmd_ack\":\n      return \"redirect.amqp\";\n    case \"ht_key\":\n    case \"hotkey\":\n      return \"command.output.live\";\n    default:\n      throw new Error(`Unknown AMQP routing key for type: ${type}`);\n  }\n}\n```","x":320,"y":1840,"width":680,"height":400},
		{"id":"c506ea1d7f26c94f","type":"text","text":"Devuelve el **exchange** de RabbitMQ al que se debe publicar el mensaje según su `type`. Si el tipo no está contemplado, lanza error para evitar publicar a un destino incorrecto.\n\n```js\nfunction getAmqpExchange(type) {\n  switch (type) {\n    case \"cmd\":\n      return \"ako.services.backlog\";\n    case \"ht_key\":\n    case \"hotkey\":\n      return \"ako.services.commands\";\n    default:\n      throw new Error(`Unknown AMQP exchange for type: ${type}`);\n  }\n}\n\n```","x":-480,"y":1840,"width":680,"height":400},
		{"id":"65dbc543f4348f4d","type":"text","text":"Genera una **seed CRC32 dependiente del UUID**. Construye un bloque de 20 bytes con:  \n`CRC32_INITIAL_VALUE + 4 palabras de 32 bits del UUID` (en big-endian) y calcula un CRC32 sobre ese bloque usando seed `0xFFFFFFFF`. El resultado se usa luego como seed para el CRC del payload.\n\n```js\nfunction _nbiot_crc32_init(uuid) {\n  const data = new Array(20).fill(0);\n  const uniqueIdWords = _parseUuid(uuid);\n  let length = 0;\n  length += _swap_u32_to_p8(CRC32_INITIAL_VALUE, data, 0);\n  length += _swap_u32_to_p8(uniqueIdWords[0], data, 4);\n  length += _swap_u32_to_p8(uniqueIdWords[1], data, 8);\n  length += _swap_u32_to_p8(uniqueIdWords[2], data, 12);\n  length += _swap_u32_to_p8(uniqueIdWords[3], data, 16);\n  const crc = _calculateCrcWithSeed(0xffffffff, data, length);\n  return crc >>> 0;\n}\n\n```","x":-1880,"y":2200,"width":680,"height":400},
		{"id":"360a4796b821824e","type":"text","text":"Implementa el **CRC32 bit-a-bit** con seed inicial `crcIni` y el polinomio `POLYNOMIAL` (0x04c11db7). Es una variante **MSB-first (no reflejada)**: mete cada byte en el byte más alto del registro (`byte << 24`) y desplaza a la izquierda.\n\n```js\nfunction _calculateCrcWithSeed(crcIni, p_buf, length) {\n  let crc = crcIni >>> 0;\n  let msb;\n  for (let i = 0; i < length; i++) {\n    crc = (crc ^ ((p_buf[i] << 24) >>> 0)) >>> 0;\n    for (let j = 0; j < 8; j++) {\n      msb = (crc >>> 31) & 1;\n      crc = (crc << 1) >>> 0;\n      crc ^= (((0 - msb) >>> 0) & POLYNOMIAL) >>> 0;\n    }\n  }\n  return crc >>> 0;\n}\n\n```","x":-2680,"y":2200,"width":680,"height":400},
		{"id":"fa6e1f86c0ab0f80","x":-4220,"y":1094,"width":513,"height":66,"type":"text","text":"El parse para estos parámetros lo encontramos en [recurso](https://ako0.sharepoint.com/:w:/r/teams/DesarrolloModificaciondeProducto/DEVICE_COMMUNICATION_PROTOCOL/_layouts/15/Doc.aspx?sourcedoc=%7B940D230D-38CE-4236-9333-54ED338F9679%7D&file=ALWAYS_ON_DEVICE_EN12830_COMMUNICATION_PROTOCOL_rev2.docx&action=default&mobileredirect=true&wdOrigin=TEAMS-MAGLEV.p2p_ns.rwc&wdExp=TEAMS-TREATMENT&wdhostclicktime=1771252569867&web=1)"},
		{"id":"a0c099cfded683d7","type":"text","text":"\n\n```js\nfunction createMessage(config) {\n  // “Factory / dispatcher”: devuelve el objeto mensaje apropiado según config.type\n  switch (config.type) {\n    case \"status\":\n      return createStatusMessage(config);\n    case \"event\":\n      return createEventMessage(config);\n    case \"alarm\":\n      return createAlarmMessage(config);\n    case \"audit\":\n```","x":-2800,"y":960,"width":680,"height":400}
	],
	"edges":[
		{"id":"aa752123f02b9e38","fromNode":"f3e006a82009d4b5","fromSide":"left","toNode":"62cfbfa8c535efd7","toSide":"top"},
		{"id":"e74845f44820af47","fromNode":"2f15da48202d1b4a","fromSide":"bottom","toNode":"f3e006a82009d4b5","toSide":"top"},
		{"id":"0596b07939cf4848","fromNode":"f3e006a82009d4b5","fromSide":"bottom","toNode":"e5f9a7081ff33489","toSide":"top"},
		{"id":"4e1fe8bf3becaece","fromNode":"6743868b8bcbe7a9","fromSide":"bottom","toNode":"2f15da48202d1b4a","toSide":"top"},
		{"id":"aadbdf84eb95894f","fromNode":"458c643588f49124","fromSide":"right","toNode":"fad8e67e5190cb6a","toSide":"left"},
		{"id":"0575f97980924ad8","fromNode":"fad8e67e5190cb6a","fromSide":"right","toNode":"59e6c19c03e8871a","toSide":"left"},
		{"id":"faae1084be82a3f4","fromNode":"fad8e67e5190cb6a","fromSide":"right","toNode":"5855c64898e04051","toSide":"left"},
		{"id":"1ba0d313fb0b1e12","fromNode":"e5f9a7081ff33489","fromSide":"bottom","toNode":"458c643588f49124","toSide":"top"},
		{"id":"6c7d847204ce6968","fromNode":"458c643588f49124","fromSide":"bottom","toNode":"85b1d1f10533721c","toSide":"top"},
		{"id":"e8569005f08c799d","fromNode":"5f7222baac878007","fromSide":"left","toNode":"a0c099cfded683d7","toSide":"right","label":"createMessage(config)"},
		{"id":"dc765612ddb23a96","fromNode":"458c643588f49124","fromSide":"bottom","toNode":"5f7222baac878007","toSide":"top"},
		{"id":"96e690b4db9bbfaa","fromNode":"85b1d1f10533721c","fromSide":"bottom","toNode":"a48a38e92b7874ea","toSide":"top"},
		{"id":"93b86ef105cd1a6f","fromNode":"85b1d1f10533721c","fromSide":"bottom","toNode":"c506ea1d7f26c94f","toSide":"top"},
		{"id":"8b1bb50d69abd17e","fromNode":"5f7222baac878007","fromSide":"bottom","toNode":"e56351d6644c1555","toSide":"top"},
		{"id":"bbd86362e064753f","fromNode":"e56351d6644c1555","fromSide":"bottom","toNode":"65dbc543f4348f4d","toSide":"top"},
		{"id":"9111981dbf2a5d99","fromNode":"e56351d6644c1555","fromSide":"bottom","toNode":"360a4796b821824e","toSide":"top"},
		{"id":"1df38551e1dca87f","fromNode":"a0c099cfded683d7","fromSide":"bottom","toNode":"bbf512112efe5f68","toSide":"right"},
		{"id":"963d2fc02b032c1a","fromNode":"a0c099cfded683d7","fromSide":"top","toNode":"914a4efb658784a8","toSide":"right"},
		{"id":"6170a8d066348072","fromNode":"914a4efb658784a8","fromSide":"left","toNode":"fa6e1f86c0ab0f80","toSide":"top"},
		{"id":"45cb90eee959b3e6","fromNode":"bbf512112efe5f68","fromSide":"left","toNode":"fa6e1f86c0ab0f80","toSide":"bottom"}
	]
}