{
	"nodes":[
		{"id":"e7668fad81c75ec8","type":"text","text":"Se declaran dos “componentes” que el micro usará: uno para **acceso a datos** (`manager`) y otro para **autenticación/validación de dispositivo** (`authentication`). Normalmente se inicializan en el constructor o en un método\n```js\nclass PerteCoapMicro extends Microservice {\n  // \"manager\" es una dependencia interna del micro que centraliza acceso a datos:\n  // típicamente DB (Mongo), cache (Redis/memoria), repositorios, etc.\n  // Se usa para leer/escribir información de dispositivos, configuraciones, mensajes, etc.\n  private manager: DataAccessManager;\n  // \"authentication\" es la dependencia encargada de autenticar/autorizar:\n  // validar que el dispositivo que envía el mensaje es válido (serial/uuid),\n  // y que el mensaje puede procesarse (licencia, pertenencia a compañía, etc.).\n  private authentication: Authentication;\n}\n\n```","x":1658,"y":-132,"width":722,"height":352},
		{"id":"ee11e1b132d764a6","type":"text","text":">[!warning] WorkFlow hacia DataAccessManager\n>[[AKO 44 - Conexion Layer workflow - DataAccessManager.canvas]]\n\n","x":2900,"y":-87,"width":560,"height":131},
		{"id":"469ab70273050323","type":"text","text":">[!warning] WorkFlow hacia Authentication\n>[[AKO 44 - Conexion Layer - Authentication.canvas]]\n\n","x":2900,"y":155,"width":560,"height":125},
		{"id":"875acb5cd184c549","type":"text","text":"Este bloque inicializa el micro y su cache. Define el puerto CoAP configurable por variable de entorno, con un valor por defecto. Declara una referencia para guardar la instancia del servidor CoAP cuando se arranque. Y configura parámetros del protocolo CoAP (timeouts, retransmisiones y ventana de respuesta), que controlan fiabilidad y tiempos de espera al comunicarse con dispositivos.\n\n```js\nconstructor() {\n  // Llama al constructor de la clase base Microservice con el directorio actual.\n  // Normalmente aquí se inicializan cosas comunes: logger, configuración, conexión a Rabbit, modelos, etc.\n  super(__dirname);\n  // Inicializa una cache (en memoria/redis/etc. según implementación) con un namespace para este micro.\n  // Sirve para almacenar datos temporales (p.ej. device lookups, tokens, resultados de auth) y evitar recalcular/consultar DB.\n  initializeCache(\"micros-perte-coap\");\n}\n// Puerto donde escuchará el servidor CoAP.\n// Si la variable de entorno COAP_PERTE_PORT existe, la usa.\n// Si no existe, usa el valor por defecto 5685.\nprivate _coapPort: number = process.env.COAP_PERTE_PORT\n  ? Number(process.env.COAP_PERTE_PORT)\n  : 5685;\n// Referencia al servidor CoAP (la instancia real se asignará cuando lo arranques).\n// Está tipado como `any` porque la librería CoAP no siempre tiene tipos TS completos o se evita tipar.\nprivate _coapServer: any;\n// Configuración del comportamiento del stack CoAP (timeouts y retransmisiones).\n// Ajusta cómo se gestionan ACKs y reintentos a nivel de protocolo.\nprivate _coapConfig = {\n  ackTimeout: 30,        // tiempo base de espera de ACK (según la lib, suele ser segundos)\n  ackRandomFactor: 1.0,  // jitter del ackTimeout (1.0 = sin variación)\n  maxRetransmit: 0,      // número máximo de retransmisiones (0 = no reintenta)\n  maxLatency: 30,        // latencia máxima estimada (segundos)\n  piggybackReplyMs: 30000, // ventana para responder “piggyback” (ms)\n};\n\n```","x":1658,"y":340,"width":722,"height":352},
		{"id":"2e3c3b0a996605e2","type":"text","text":">[!warning] Esta clase hereda de microservicios\n>Crear un workFlow hacia ese micro.\n\n","x":680,"y":300,"width":722,"height":131},
		{"id":"7df491d62c9718df","type":"text","text":">[!warning] Workoflow del cache\n>Crear un workFlow hacia ese micro.\n\n","x":680,"y":561,"width":722,"height":131},
		{"id":"4eefdd053f448f49","type":"text","text":"Esta función arranca el servidor CoAP del micro, pero solo si una variable de entorno lo habilita. Antes de eso inicializa autenticación porque el micro también depende de ella para integrarse con RabbitMQ. Configura los timings del protocolo CoAP y crea el servidor. Registra handlers para errores y para requests entrantes, delegando el procesamiento a métodos privados. Finalmente abre el puerto y deja el servidor escuchando.\n\n```js\npublic startServer() {\n  // Inicializa Authentication siempre.\n  // Comentario del autor: se necesita aunque no arranques CoAP, porque el micro igual usa RabbitMQ.\n  this.initializeAuthentication();\n  // Feature flag: permite activar/desactivar el servidor CoAP por variable de entorno.\n  const coapEnabled = process.env.COAP_PERTE_SERVER_ENABLED === \"true\";\n  this.log(\"info\", `COAP PERTE SERVER ENABLED: ${coapEnabled}`);\n  // Solo arranca el servidor si está habilitado.\n  if (coapEnabled) {\n    // Aplica la configuración de timings CoAP (timeouts, retransmisiones, piggyback, etc.)\n    coap.updateTiming(this._coapConfig);\n    // Crea el servidor CoAP (la lib expone un event emitter con eventos como request/error/end)\n    this._coapServer = coap.createServer();\n    // Maneja un error global del servidor (se registra una sola vez)\n    this._coapServer.once(\"error\", (error: Error) => this._onError(error));\n    // Maneja el fin de una request (útil para limpiar recursos o loguear)\n    this._coapServer.on(\"end\", (requestEnd: coap.IncomingMessage) =>\n      this._onEndRequest(requestEnd)\n    );\n    // Evento principal: cuando entra una request CoAP.\n    // Aquí se delega a _onMessage para procesar el payload y responder.\n    this._coapServer.on(\n      \"request\",\n      (request: coap.IncomingMessage, response: coap.OutgoingMessage) =>\n        this._onMessage(request, response)\n    );\n    try {\n      // Arranca el listener en el puerto configurado\n      this._coapServer.listen(this._coapPort, () => {\n        this.log(\n          \"info\",\n          `[CL-COAP] SERVER LISTENING ON PORT: ${this._coapPort}`\n        );\n      });\n    } catch (error) {\n      // Captura errores al arrancar (p.ej. puerto ocupado, permisos, etc.)\n      this._handleError(error, \"FAILED TO START SERVER\");\n    }\n  }\n}\n```","x":1658,"y":800,"width":722,"height":352},
		{"id":"1c5a17d77c4c12d5","type":"text","text":"Esta función monta todo el “stack” de autenticación del micro CoAP. Carga modelos de Mongo y construye un adaptador de base de datos, que se registra en un `DataAccessManager`. Encima crea repositorios (device, manufacturedDevice, firmware, etc.) para encapsular las consultas. Con esos repositorios instancia `Authentication`, indicando que el canal es “coap”. Finalmente abre la conexión del manager (con la nota de que podría faltar esperar a la conexión si es asíncrona).\n\n```js\nprivate initializeAuthentication() {\n  // Obtiene modelos Mongoose ya registrados en el micro (colecciones de Mongo)\n  // Estos modelos se usarán para consultar información de dispositivos, ficheros, IPs, firmware, etc.\n  const deviceModel: Model<DeviceModel> = this.getModel(\"device\");\n  const manufacturedDeviceModel: Model<ManufacturedDeviceModel> =\n    this.getModel(\"manufacturedDevice\");\n  const PlmnList: Model<PlmnListModel> = this.getModel(\"plmnlist\");\n  const FirmwareUpdate: Model<FirmwareUpdateModel> =\n    this.getModel(\"firmwareUpdate\");\n  const ModemFirmware: Model<ModemFirmwareUpdateModel> = this.getModel(\n    \"modemFirmwareUpdate\"\n  );\n  const File: Model<FileModel> = this.getModel(\"file\");\n  const Ip: Model<IPModel> = this.getModel(\"ip\");\n\n  // Construye un adapter de acceso a datos para Mongo, registrando los modelos que se van a usar.\n  // La idea es encapsular Mongo detrás de una interfaz común (DatabaseAdapter).\n  const mongoAdapter: DatabaseAdapter = new DatabaseAdapterBuilder()\n    .addModel(\"device\", deviceModel)\n    .addModel(\"manufacturedDevice\", manufacturedDeviceModel)\n    .addModel(\"file\", File)\n    .addModel(\"ip\", Ip)\n    .addModel(\"plmnlist\", PlmnList)\n    .addModel(\"firmwareUpdate\", FirmwareUpdate)\n    .addModel(\"modemFirmwareUpdate\", ModemFirmware)\n    .forMongo()\n    .build();\n  // Adapter de cache (Redis) está previsto pero comentado.\n  // Si se activara, serviría para cachear lookups frecuentes (device/license/uuid, etc.).\n  // const redisAdapter: DatabaseAdapter = new DatabaseAdapterBuilder()\n  //   .setPort(parseInt(process.env.REDIS_PORT))\n  //   .setHost(process.env.REDIS_HOST)\n  //   .forCache()\n  //   .build();\n  // DataAccessManager coordina uno o varios adapters (Mongo, Redis, etc.)\n  const manager: DataAccessManager = new DataAccessManager();\n  this.manager = manager;\n  // Carga el adapter de Mongo en el manager (Redis está desactivado en este momento)\n  // manager.loadAdapter(mongoAdapter).loadAdapter(redisAdapter, 0);\n  manager.loadAdapter(mongoAdapter);\n  // Crea repositorios (capa de acceso) que consumen el manager para consultar/actualizar datos\n  const deviceRepo: DeviceRepository = new DeviceRepository(manager);\n  const manufacturedDeviceRepo: ManufacturedDeviceRepository =\n    new ManufacturedDeviceRepository(manager);\n  const fileRepo: FileRepository = new FileRepository(manager);\n  const firmwareUpdateRepo: FirmwareUpdateRepository =\n    new FirmwareUpdateRepository(manager);\n  const plmnListRepo: PlmnListRepository = new PlmnListRepository(manager);\n  const modemFirmwareUpdateRepo: ModemFirmwareUpdateRepository =\n    new ModemFirmwareUpdateRepository(manager);\n  const ipRepo: IPRepository = new IPRepository(manager);\n  // Construye el componente de Authentication con todas las dependencias que necesita:\n  // - repos para validar device/uuid/licencia\n  // - acceso a ficheros y firmware (posibles flujos de actualización)\n  // - plmnlist (NB-IoT / redes móviles)\n  // - ipRepo (probable whitelist/validación por IP si aplica)\n  // - \"coap\" como tipo de canal/protocolo (para reglas específicas)\n  this.authentication = new Authentication(\n    deviceRepo,\n    manufacturedDeviceRepo,\n    fileRepo,\n    firmwareUpdateRepo,\n    modemFirmwareUpdateRepo,\n    plmnListRepo,\n    this,\n    \"coap\",\n    ipRepo\n  );\n  // Conecta el manager a los adapters cargados.\n  // OJO: el comentario sugiere un posible problema: connect() puede ser async y aquí no se espera (await).\n  // Eso podría provocar que se use authentication antes de que Mongo esté completamente conectado.\n  // FIXME: posible problema de asinconía\n  manager.connect();\n}\n\n```","x":2781,"y":800,"width":722,"height":352},
		{"id":"e5f676270a09aea5","type":"text","text":">[!info] Repository y Adapter Pattern\n\nEl **Adapter Pattern** aparece en `DatabaseAdapterBuilder().forMongo().build()`: se crea un **adaptador de persistencia** que “envuelve” Mongo/Mongoose detrás de una interfaz (`DatabaseAdapter`).\nEse adaptador registra modelos con claves (`\"device\"`, `\"file\"`, `\"ip\"`, etc.), de modo que el resto del código no depende directamente de imports de Mongoose en cada sitio.\n`DataAccessManager` actúa como **orquestador/fachada**: carga uno o varios adapters (Mongo y potencialmente Redis). Eso permite cambiar/añadir storage sin reescribir la lógica de negocio.\nEl **Repository Pattern** aparece cuando se crean repositorios (`DeviceRepository`, `FileRepository`, `FirmwareUpdateRepository`, …). Cada repo expone operaciones de datos con intención de dominio (buscar device, validar manufactured, etc.) usando el `manager`.\nLa clase `Authentication` consume **repositorios**, no Mongoose: eso desacopla la autenticación de la tecnología de base de datos.\nSi mañana se activa Redis, el adapter de cache se añade al `manager` y los repos podrían consultar cache→mongo sin cambiar `Authentication`.\nEl efecto práctico es: **persistencia pluggable (adapter)** + **API de datos orientada a negocio (repository)**, reduciendo acoplamiento y facilitando test/mocks.","x":3820,"y":580,"width":543,"height":352},
		{"id":"33d0bb5e59a9c651","type":"text","text":"Este handler se ejecuta cuando una request CoAP finaliza y genera un log “warning” con el método, la URI y el payload (si lo hay), principalmente para trazabilidad/diagnóstico.\n\n```js\nprivate _onEndRequest(requestEnd: coap.IncomingMessage): void {\n  // Si la request trae payload, lo convierte a string para loguearlo.\n  // OJO: requestEnd.payload suele ser Buffer; JSON.stringify(Buffer) genera algo tipo:\n  // {\"type\":\"Buffer\",\"data\":[...]} (no el contenido decodificado).\n  const payloadMessage = requestEnd.payload\n    ? JSON.stringify(requestEnd.payload)\n    : \"No payload\";\n  // Loggea que la petición CoAP ha terminado, incluyendo:\n  // - método (GET/POST/...)\n  // - URL/URI\n  // - payload (en bruto, como JSON del Buffer)\n  this.log(\n    \"warning\",\n    `[CL-COAP] REQUEST ENDED - Method: ${requestEnd.method}, URI: ${requestEnd.url}, Payload: ${payloadMessage}`\n  );\n}\n\n```","x":440,"y":800,"width":722,"height":352},
		{"id":"c631530d4568938d","type":"text","text":"Este handler es el punto de entrada para cada request CoAP. Si RabbitMQ no está disponible, responde 503. Si está disponible, añade handlers de error, registra trazas, extrae el `serialNumber`, deduce la acción del request y empaqueta toda la información (payload + IP + acción) en un `MessageParseCl` para pasarlo al flujo de validación/procesado.\n\n```js\nprivate async _onMessage(\n  request: coap.IncomingMessage,\n  response: coap.OutgoingMessage\n): Promise<void> {\n  // Si no hay conexiones AMQP (RabbitMQ) levantadas, el micro no puede publicar hacia el pipeline.\n  // Responde al dispositivo con 503 (Service Unavailable).\n  if (!this._amqpServersConections) {\n    this._sendResponseToClient(response, 503);\n  } else {\n    // Engancha handlers de error para request/response (timeouts, errores de socket, etc.)\n    this._attachErrorHandlers(request, response);\n    // Logs de trazabilidad para ver que llega una petición y su contenido (en bruto)\n    this.log(\"info\", \"PerteCoapMicro\", \"#########################\");\n    this.log(\"info\", \"PerteCoapMicro\", JSON.stringify(request));\n    this.log(\"info\", \"PerteCoapMicro\", \"#########################\\n\");\n    // Extrae el serialNumber desde la URL/endpoint CoAP (p.ej. /<sn>/sn o similar)\n    const serialNumber = this._extractSerialNumberFromRequest(request);\n    // Determina qué acción es (por ejemplo create/retrieve) según método/URL/campos del request\n    const requestAction = this._getRequestAction(request);\n    // IP origen del device (socket/rsinfo que da la librería CoAP)\n    const ipRequest = request.rsinfo.address;\n    // Construye el objeto “normalizado” que usará el resto del pipeline (Authentication, etc.)\n    const messageParseCl: MessageParseCl = {\n      serialNumber: serialNumber,\n      payload: request.payload,   // payload en bytes (Buffer), aún sin decodificar/validar CRC\n      ipRequest: ipRequest,\n      requestAction: requestAction,\n    };\n    // (El resto del método normalmente llamará a Authentication.checkMessageRecived(...)\n    // y responderá/publicará según resultado.)\n  }\n}\n\n```","x":440,"y":1260,"width":722,"height":352},
		{"id":"7e93bdb0d365d4a9","type":"text","text":"Se deriva una acción extra desde la request (`_getRetiveAction`). Si existe (no es string vacío), se agrega al mensaje normalizado `messageParseCl` como propiedad `retiveAction`, usando `_.set` para asignarla de forma segura aunque no estuviera definida.\n\n```js\nconst retiveAction = this._getRetiveAction(request);\n// Calcula una acción “especial” de tipo retrieve/link/etc. a partir del request CoAP.\n// Si la acción no está vacía, la añade dinámicamente al objeto messageParseCl.\nif (retiveAction != \"\") {\n  // Usa lodash _.set para crear/asignar la propiedad aunque no exista aún\n  // (y soporta paths tipo \"a.b.c\", aunque aquí se usa un nombre simple).\n  _.set(messageParseCl, \"retiveAction\", retiveAction);\n\n\n  const checkMessage = await this._checkDeviceAndMessage(messageParseCl);\n}\n```","x":440,"y":2180,"width":722,"height":352},
		{"id":"3c8f32709f0454e4","type":"text","text":">[!warning]\nEsta constante llama a la función de \nhace las comprobaciones principales: validar dispositivo (serial/BD), validar integridad (CRC/decodificación) y decidir si procesa/publica al translator según licencia o `link`.authentication.checkMessageRecived\n\n","x":1540,"y":2326,"width":420,"height":206},
		{"id":"c71ff16cdce81e6a","type":"text","text":"Responde 200 si todo fue correcto (y opcionalmente devuelve un body), o 405 si algo falló.\n\n```js\nif (checkMessage.status == \"success\") {\n  // Si las validaciones/procesado han sido OK, responde al dispositivo con 200.\n  this.log(\"info\", \"PerteCoapMicro\", \"response to device: 200\");\n  // Envía 200 y, si existe, incluye el body devuelto por Authentication/processor.\n  this._sendResponseToClient(\n    response,\n    200,\n    checkMessage.body ? checkMessage.body : undefined\n  );\n} else {\n  // Si ha fallado alguna validación/procesado, responde con 405.\n  this.log(\"error\", \"PerteCoapMicro\", \"response to device: 405\");\n  // Envía 405 sin body.\n  this._sendResponseToClient(response, 405);\n}\n\n```","x":440,"y":2640,"width":722,"height":352},
		{"id":"502e70cf1c08a15d","type":"text","text":"Se deriva una acción extra desde la request (`_getRetiveAction`). Si existe (no es string vacío), se agrega al mensaje normalizado `messageParseCl` como propiedad `retiveAction`, usando `_.set` para asignarla de forma segura aunque no estuviera definida.\n\n```js\nconst retiveAction = this._getRetiveAction(request);\n// Calcula una acción “especial” de tipo retrieve/link/etc. a partir del request CoAP.\n// Si la acción no está vacía, la añade dinámicamente al objeto messageParseCl.\nif (retiveAction != \"\") {\n  // Usa lodash _.set para crear/asignar la propiedad aunque no exista aún\n  // (y soporta paths tipo \"a.b.c\", aunque aquí se usa un nombre simple).\n  _.set(messageParseCl, \"retiveAction\", retiveAction);\n}\n```","x":440,"y":1720,"width":722,"height":352},
		{"id":"d5636761c557597d","type":"text","text":"Envía la respuesta CoAP con `Content-Format: application/json`; si hay `message`, lo serializa y lo manda, si no, cierra la respuesta sin contenido.\n\n```js\nprivate _sendResponseToClient(\n  response: coap.OutgoingMessage,\n  code: number = 200,\n  message?: any\n): void {\n  // Si hay mensaje (body) lo devuelve como JSON.\n  if (message !== undefined && message !== null) {\n    const responseBody = JSON.stringify(message);\n    // Log del body que se envía al dispositivo.\n    this.log(\"info\", \"PerteCoapMicro\", \"body response to device:\" + responseBody);\n    // Cabeceras CoAP indicando JSON.\n    response.writeHead(code, { \"Content-Format\": \"application/json\" });\n    // Envía body y termina la respuesta.\n    response.end(responseBody);\n  } else {\n    // Si no hay body, responde solo con cabeceras y el código.\n    this.log(\"info\", \"PerteCoapMicro\", \"no body response to device\");\n    response.writeHead(code, { \"Content-Format\": \"application/json\" });\n    response.end();\n  }\n}\n\n```","x":-700,"y":2640,"width":722,"height":352}
	],
	"edges":[
		{"id":"095d6b839308ed06","fromNode":"e7668fad81c75ec8","fromSide":"right","toNode":"ee11e1b132d764a6","toSide":"left","label":"DataAccessManager"},
		{"id":"8defdaf53a1d0a52","fromNode":"e7668fad81c75ec8","fromSide":"right","toNode":"469ab70273050323","toSide":"left","label":"Authentication"},
		{"id":"eda0899c0084dca8","fromNode":"875acb5cd184c549","fromSide":"left","toNode":"2e3c3b0a996605e2","toSide":"right","label":"extends Microservice"},
		{"id":"ad8bcf433388e10f","fromNode":"875acb5cd184c549","fromSide":"left","toNode":"7df491d62c9718df","toSide":"right","label":"initializeCache"},
		{"id":"7b56a9c9c80c1e0f","fromNode":"e7668fad81c75ec8","fromSide":"bottom","toNode":"875acb5cd184c549","toSide":"top"},
		{"id":"9c1863f406b1c4f4","fromNode":"4eefdd053f448f49","fromSide":"right","toNode":"1c5a17d77c4c12d5","toSide":"left","label":"initializeAuthentication"},
		{"id":"aef2f864baa8547f","fromNode":"1c5a17d77c4c12d5","fromSide":"top","toNode":"e5f676270a09aea5","toSide":"top","label":"Info sobre Patron Repositorio y Adaptador"},
		{"id":"f1b084542ae1e13d","fromNode":"4eefdd053f448f49","fromSide":"left","toNode":"33d0bb5e59a9c651","toSide":"right","label":"_onEndRequest"},
		{"id":"a3889bbfc10188fb","fromNode":"4eefdd053f448f49","fromSide":"left","toNode":"c631530d4568938d","toSide":"right","label":"_onMessage"},
		{"id":"eddf731476cbc4bf","fromNode":"c631530d4568938d","fromSide":"bottom","toNode":"502e70cf1c08a15d","toSide":"top"},
		{"id":"0cffe61557dddb85","fromNode":"3c8f32709f0454e4","fromSide":"top","toNode":"469ab70273050323","toSide":"bottom"},
		{"id":"bf2214cc04a790a7","fromNode":"7e93bdb0d365d4a9","fromSide":"right","toNode":"3c8f32709f0454e4","toSide":"left","label":"_checkDeviceAndMessage"},
		{"id":"353f4e4d66bc4ba3","fromNode":"502e70cf1c08a15d","fromSide":"bottom","toNode":"7e93bdb0d365d4a9","toSide":"top"},
		{"id":"c25aacae6af69d97","fromNode":"7e93bdb0d365d4a9","fromSide":"bottom","toNode":"c71ff16cdce81e6a","toSide":"top"},
		{"id":"8e5b1dc9ca13cf10","fromNode":"c71ff16cdce81e6a","fromSide":"left","toNode":"d5636761c557597d","toSide":"right","label":"_sendResponseToClient"}
	]
}