{
	"nodes":[
		{"id":"c5e93977b132aeaf","type":"text","text":"Esta función decide si el mensaje proviene de un dispositivo con firmware compatible. Primero verifica que exista la información básica del dispositivo. Luego intenta obtener la versión de firmware desde el propio mensaje; si falta, la deduce desde la definición del dispositivo en base de datos. Finalmente compara esa versión contra un conjunto de versiones permitidas. Si no puede obtenerla o no está permitida, devuelve `false` y el mensaje se descarta.\n\n```js\nprivate async validateFirmwareVersion(\n  message: ClOutgoingMessage,\n): Promise<boolean> {\n  // Extrae la información del dispositivo que viene “envolviendo” el payload\n  const deviceInformation: DeviceInformation = message.deviceInformation;\n  // Si falta el objeto device dentro de deviceInformation, no puede saber versión/compatibilidad\n  if (!deviceInformation.device) {\n    this.logger.warn(\n      \"Device information is incomplete. Device property is missing.\" +\n        JSON.stringify(deviceInformation),\n    );\n    return false; // mensaje inválido para este validador\n  }\n  // Intenta leer la versión de firmware directamente del mensaje\n  let firmwareVersion = deviceInformation.device.firmwareVersion;\n  // Si el mensaje no trae firmwareVersion, intenta obtenerla desde la definición de dispositivo (BD)\n  if (firmwareVersion == undefined) {\n    this.logger.info(\n      \"Firmware version not found in device information. Attempting to retrieve from device definition.\",\n    );\n    // Helper que consulta el repositorio de device definitions para este dispositivo\n    const definitionReader = new DefinitionReader(\n      this.deviceDefinitionRepo,\n      deviceInformation,\n    );\n    // Busca la definición (normalmente por model/ids) y saca la versión/protocol version (pv)\n    const deviceDefinition: DeviceDefinition =\n      await definitionReader.getDeviceDefinition();\n\n    // Si encuentra definición y tiene pv, la usa como firmwareVersion “efectiva”\n    if (deviceDefinition && deviceDefinition.pv) {\n      firmwareVersion = deviceDefinition.pv;\n      this.logger.info(\n        `Retrieved firmware version from device definition: ${firmwareVersion}`,\n      );\n    } else {\n      // Si ni viene en el mensaje ni se puede deducir de la definición, se descarta\n      this.logger.error(\n        \"Unable to retrieve firmware version from device definition.\",\n      );\n      return false;\n    }\n  }\n  // Check final: la versión debe estar en la lista/set de version\n```","x":-404,"y":-610,"width":712,"height":260},
		{"id":"714ae963cef6ffee","type":"text","text":"Esta función intenta identificar el tipo de mensaje mirando el campo `ty` del payload. Si el payload no es un objeto o no tiene `ty`, lo rechaza. Con el `ty` busca el esquema de validación correspondiente; si no existe, el tipo no está soportado. Si existe, valida el payload contra ese esquema. Si la validación pasa, devuelve el tipo; si falla, devuelve `undefined` y el mensaje se descarta.\n\n```js\nprivate parsePayload(message: ClOutgoingMessage): MessageType | undefined {\n  // Saca el payload \"tal cual\" viene dentro del mensaje que llega al translator\n  const { payload } = message;\n  // 1) Comprobación mínima: payload debe ser un objeto y debe tener el campo 'ty' (tipo de mensaje)\n  //    Si no existe 'ty', el translator no sabe qué schema aplicar ni cómo rutearlo.\n  if (typeof payload !== \"object\" || !(\"ty\" in payload)) {\n    this.logger.error(\n      `WRONG payload format or missing 'ty' field :: ${JSON.stringify(payload)}`,\n    );\n    return undefined; // inválido -> no se puede determinar tipo\n  }\n  // 2) Extrae el tipo (ej: \"event\", \"sample\", \"status\", etc.)\n  const { ty } = payload as PayloadWithType;\n  // 3) Busca el schema JSON asociado a ese tipo.\n  //    Si no hay schema, significa que ese tipo no está soportado/registrado.\n  const schema = this.getSchemaForMessageType(ty);\n  if (!schema) {\n    this.logger.warn(`WRONG MessageType <${ty}> :: Schema not found.`);\n    return undefined; // tipo desconocido -> inválido\n  }\n  // 4) Valida el payload contra el schema del tipo.\n  //    jsonValidator devuelve algo como { valid: true/false, errors: ... }\n  if (this.jsonValidator.validate(payload, schema).valid) {\n    // Si cuadra con el schema, se acepta y devuelve el tipo para que el flujo continúe\n    this.logger.info(\n      `VALID MessageType <${ty}> and VALID payload schema :: ${JSON.stringify(payload)}`,\n    );\n    return ty as MessageType;\n  } else {\n    // Si el tipo es conocido pero la estructura/campos no cumplen el schema, se rechaza\n    this.logger.warn(\n      `VALID MessageType <${ty}> but WRONG payload schema :: ${JSON.stringify(payload)}`,\n    );\n    return undefined;\n  }\n}\n```","x":-404,"y":-50,"width":712,"height":260},
		{"id":"15a506e33ab0c14e","type":"text","text":"\nEsta función decide si un mensaje entrante “pasa” o “se descarta”. Primero verifica compatibilidad del dispositivo por firmware; si no encaja, corta ahí. Si encaja, inspecciona el payload para detectar el tipo y validar su estructura con un esquema. Si obtiene un tipo válido, devuelve `isValid: true` y ese tipo; si algo falla, devuelve inválido.\n\n```js\nasync validateMessage(\n  message: ClOutgoingMessage\n): Promise<{ isValid: boolean; messageType?: MessageType }> {\n  try {\n    // 1) Comprueba si el dispositivo/mensaje es compatible a nivel \"firmware\".\n    //    Esto suele implicar leer firmwareVersion del message.deviceInformation\n    //    o, si falta, buscarlo en la definición del dispositivo (BD).\n    const isFirmwareValid = await this.validateFirmwareVersion(message);\n    // Si el firmware NO es aceptable, el mensaje se descarta sin seguir validando el payload.\n    if (!isFirmwareValid) {\n      return { isValid: false };\n    }\n    // 2) Si el firmware es compatible, valida el payload:\n    //    - comprueba que exista 'ty'\n    //    - busca el schema del tipo\n    //    - valida el JSON contra ese schema\n    //    Si todo cuadra, devuelve el tipo (messageType).\n    const messageType = this.parsePayload(message);\n    // Devuelve:\n    // - isValid: true si hay tipo reconocido y schema válido\n    // - messageType: el tipo detectado (event, sample, status, etc.)\n    return {\n      isValid: !!messageType,     // convierte messageType a boolean (undefined => false)\n      messageType: messageType,   // el tipo, si existe\n    };\n  } catch (error) {\n    // Si ocurre cualquier excepción (BD, schema, parseo, etc.), marca como inválido.\n    this.logger.error(\"An error occurred during input validation:\" + error);\n    return { isValid: false };\n  }\n}\n```","x":-1504,"y":-350,"width":712,"height":260},
		{"id":"e61766f46ba76c35","type":"text","text":"Cómo encaja con `MessageType` y `Map.get(...)`\n- `MessageType` es el catálogo de tipos permitidos (strings como `\"event\"`, `\"sample\"`, `\"status\"`, etc.).\n- `schemaMap` es un `Map<MessageType, object>` que contiene entradas del estilo:\n- `get(key)` (la firma que pusiste) significa:\n    - “Dame el valor asociado a `key`”\n    - o `undefined` si no hay ninguna entrada para esa clave.\n**Traducción directa:** si llega `ty: \"event\"`, aquí se intenta obtener `schemaMap.get(\"event\")`. Si no existe, el payload se rechaza aunque `ty` sea un string válido.\n\n```js\nschemaMap.set(MessageType.EVENT, eventSchema);\nschemaMap.set(MessageType.SAMPLE, sampleSchema);\n```","x":640,"y":340,"width":712,"height":260},
		{"id":"870abda2e71c196c","type":"file","file":"AKO/AKO44/Docs/attachments/Pasted image 20260217165606.png","x":1540,"y":70,"width":249,"height":400},
		{"id":"fd95761b982b5c49","type":"text","text":"Esta función es un “diccionario” de esquemas. Le pasas un tipo de mensaje y te devuelve el schema que corresponde. Si el tipo no está registrado en ese diccionario, devuelve `undefined`. Eso provoca que el validador considere el mensaje como “tipo no soportado” o “sin schema”.\n\n```js\nprivate getSchemaForMessageType(\n  messageType: MessageType,\n): object | undefined {\n  // Busca en un Map (schemaMap) el schema asociado a ese tipo de mensaje.\n  // Si existe: devuelve el objeto schema (JSON schema).\n  // Si NO existe: devuelve undefined.\n  return this.schemaMap.get(messageType);\n}\n```","x":640,"y":-50,"width":712,"height":260},
		{"id":"b55d1ce883ba0d57","type":"text","text":"### _validateMessage_","x":-1400,"y":-480,"width":421,"height":50}
	],
	"edges":[
		{"id":"8b0e6ec13c77303b","fromNode":"fd95761b982b5c49","fromSide":"bottom","toNode":"e61766f46ba76c35","toSide":"top","label":"schemaMap.get"},
		{"id":"afac8637c79fdaa5","fromNode":"fd95761b982b5c49","fromSide":"right","toNode":"870abda2e71c196c","toSide":"left"},
		{"id":"ecbc72c97255de87","fromNode":"714ae963cef6ffee","fromSide":"right","toNode":"fd95761b982b5c49","toSide":"left"},
		{"id":"1995279facfbe5b8","fromNode":"15a506e33ab0c14e","fromSide":"right","toNode":"c5e93977b132aeaf","toSide":"left","label":"validateFirmwareVersion"},
		{"id":"f4d2db1a5e67e14a","fromNode":"15a506e33ab0c14e","fromSide":"right","toNode":"714ae963cef6ffee","toSide":"left","label":"parsePayload"},
		{"id":"26a5d586fb33c529","fromNode":"b55d1ce883ba0d57","fromSide":"bottom","toNode":"15a506e33ab0c14e","toSide":"top"}
	]
}