{
	"nodes":[
		{"id":"8129726b3bdc176b","type":"text","text":">[!info] Akocloud - api\n>[[AKO 44 - Flujo Api Device.canvas]]","x":-538,"y":-409,"width":758,"height":129},
		{"id":"c964a970e83085ce","type":"text","text":">[!warning]  Comportamiento de la Api\n>\n- La API recibe la petición de cambio de parámetros para un dispositivo. Comprueba permisos del usuario y carga el dispositivo con la información necesaria. \n- Si el dispositivo está en un estado en el que no admite cambios, responde con error y no continúa. \n- Extrae los cambios del body (ya sea dentro de `conf` o directamente) y un comentario opcional.\n- Filtra lo que se puede cambiar para quedarse solo con parámetros permitidos según la definición del dispositivo. Si queda algo por enviar, publica un mensaje en Rabbit con los datos del dispositivo, el usuario y la configuración. En el caso del flujo 12830, ese mensaje va con la routing key `backlog.12830.input`. Rabbit lo enruta a la cola que consume BacklogMediator. El mediator toma ese mensaje, lo valida y lo transforma en cambios “limpios” y realmente aplicables. A partir de ahí, el mediator vuelve a publicar eventos para auditoría y para generar el backlog de nueva configuración.","x":-538,"y":-849,"width":758,"height":369},
		{"id":"c0275da77fdea6e4","type":"text","text":">[!info] AKO 44 - Micros - BacklogMediator\n>[[AKO 44 - Flujo backlog.perte mediator.canvas]]","x":520,"y":-409,"width":758,"height":129},
		{"id":"b5cf2842674df923","type":"text","text":"Rabbit","x":240,"y":-200,"width":250,"height":120},
		{"id":"fe3f148d79cee836","type":"text","text":">[!info] AKO 44 - Micros  Backlog.stateController\n>[[AKO 44 - backlog.perte stateController Workflow.canvas]]","x":1562,"y":-409,"width":758,"height":129},
		{"id":"7a62a94f79619a35","type":"text","text":">[!warning]  Microservicio BacklogMediator (12830)\n\nRecibe mensajes con cambios de configuración. Si todavía no tiene preparado el validador, lo inicializa con acceso a base de datos de dispositivos y definiciones. Convierte el mensaje de texto a objeto JSON y, si viene mal formado, lo descarta. Verifica que el mensaje tenga los campos mínimos esperados (serie, modelo, fecha, usuario, comentario y configuración). Valida el mensaje contra la base de datos para asegurar que el dispositivo y su definición son correctos. Recorre los parámetros enviados y los compara con la configuración actual del dispositivo. Convierte valores numéricos cuando hace falta y comprueba que estén dentro de rango, incluso cuando el rango depende de condiciones del propio dispositivo. Se queda solo con cambios reales (valores distintos) y válidos. Separa los cambios en dos grupos: los que son para aplicar al dispositivo y los que son para auditoría. Publica eventos de salida solo si hay cambios: uno para auditoría y otro para crear/aplicar un nuevo backlog de configuración.\nDespués de clasificar, el mediator publica el mensaje de configuración como evento **`backlog.12830.new.conf`** (solo si hay cambios reales). Ese evento es el que consume **StateController** en `handleNewConfiguration`, para guardar/actualizar el backlog pendiente y luego emitir **`driver.output.12830`** con el resultado.","x":520,"y":-849,"width":758,"height":369},
		{"id":"2541e542989c91d9","type":"text","text":">[!warning]  Microservicio Backlog.stateController (12830)\n>\n\nEste micro recibe mensajes de “nueva configuración” ya clasificados y listos para aplicar. Primero asegura que su `BacklogProcessor` (y dependencias) estén inicializados con acceso a base de datos de backlog, dispositivos, definiciones y auditoría. Convierte el mensaje recibido de texto a objeto JSON y, si no puede, lo descarta. Verifica que el mensaje tenga los campos mínimos (`device`, `user`, `timestamp`, `config`) y que `config` sea una lista; si no, lo rechaza. Luego entrega el mensaje al `BacklogProcessor`, que decide si hay un backlog pendiente para ese dispositivo. Si existe, actualiza solo los cambios que siguen pendientes y añade los nuevos que no estaban. Si no existe backlog pendiente, crea uno nuevo en estado `pending` con esos cambios. Finalmente devuelve una lista de “pendingItems” (lo que queda pendiente) y, si hay resultado, publica un evento `driver.output.12830` para que el siguiente componente (driver) continúe el flujo.","x":1562,"y":-849,"width":758,"height":369},
		{"id":"c6a6832d131c714f","type":"text","text":"Rabbit","x":1312,"y":-200,"width":250,"height":120},
		{"id":"c50ec3d92112a500","type":"text","text":"Rabbit","x":2380,"y":-200,"width":250,"height":120},
		{"id":"205ec53987630507","type":"text","text":">[!info] AKO 44 - Micros Translator\n>[[AKO 44 - Driver Translator Perte WorkFlow.canvas]]]","x":2660,"y":-409,"width":758,"height":129},
		{"id":"6c35a2c1b7d6d287","type":"text","text":">[!info] AKO 44 - Micros Translator\n>[[AKO 44 - Conexion Layer Workflow.canvas]]]","x":3720,"y":-409,"width":758,"height":129},
		{"id":"4ff436ec173360a0","type":"text","text":">[!warning]  Microservicio CoAP\n>\n\nEste micro recibe desde Rabbit el mensaje que ya viene preparado por el **translator** para enviarlo al dispositivo. En `handleCLOutput` parsea el JSON y lo pasa a `_sendMessageToClient`. Ahí usa `Authentication.createMessageToSend` para construir el payload final y obtener la información del dispositivo (especialmente su IP y serial). Con esos datos lanza un **CoAP POST** al dispositivo (`host=device.ip`, `pathname=/<serial>`, puerto 59261) y envía el payload (en formato CBOR). También puede levantar un servidor CoAP para recibir peticiones entrantes del dispositivo, validar el mensaje y responderle. Cuando entra una petición del device, extrae serial de la URL, identifica si es GET/POST, y valida/autentica contra base de datos antes de responder. Registra logs de entrada/salida para trazabilidad. Ajusta parámetros de CoAP (timeouts, retransmisiones) según configuración. Incluye un flujo alternativo para procesar mensajes de “nuevo dispositivo” simulando request/response y reutilizando la misma lógica de validación.","x":3720,"y":-849,"width":758,"height":369},
		{"id":"f0a65a0f8925ae99","type":"text","text":"Rabbit","x":3470,"y":-140,"width":250,"height":120},
		{"id":"c35497d008015692","type":"text","text":">[!warning]  Microservicio Translator \n>\n\nEste micro es el “traductor” entre mensajes del driver/backlog/API y el formato que entiende la capa de comunicación (CoAP/MQTT). Recibe mensajes, los registra en log, intenta parsearlos a JSON y descarta los que vienen mal. Comprueba que el mensaje tenga una estructura mínima (deviceInformation + payload) y, si falla, lo ignora. Inicializa bajo demanda sus dependencias: validador, servicios de mensajes de parámetros y de comandos (con acceso a BD). Valida el mensaje según su tipo (PARAM_ACK, CMD_ACK, PARAM, CMD, etc.) y decide qué camino seguir. Convierte el contenido usando `InputProcessor` y la definición del dispositivo para generar un payload “ejecutable”. Si recibe ACKs, confirma en BD que un parámetro/comando quedó aplicado y publica el dato parseado al topic correspondiente. Si no es ACK, revisa si hay mensajes pendientes y, si existen, reenvía parámetros o comandos; si se supera el máximo de reintentos, emite un evento de fallo. Cuando procesa salidas del driver/backlog (`handleOutput/handleOutputCommand/handleOutputParam`), construye un `toCLMessage` con serialNumber + payload + acción y lo guarda (paramMsg/outputMsg) antes de enviarlo. Finalmente publica hacia la capa CL el mensaje de salida, usando CoAP para NB-IoT (`cl.output.perte.coap.driver`) o MQTT si aplica.","x":2660,"y":-840,"width":758,"height":369}
	],
	"edges":[
		{"id":"d526b0386b851b03","fromNode":"8129726b3bdc176b","fromSide":"right","toNode":"b5cf2842674df923","toSide":"top"},
		{"id":"aa033d5167369cf9","fromNode":"c0275da77fdea6e4","fromSide":"left","toNode":"b5cf2842674df923","toSide":"top"},
		{"id":"32a81ae2c0fa4bfe","fromNode":"c0275da77fdea6e4","fromSide":"right","toNode":"c6a6832d131c714f","toSide":"top"},
		{"id":"57c21911b197552f","fromNode":"c964a970e83085ce","fromSide":"bottom","toNode":"8129726b3bdc176b","toSide":"top"},
		{"id":"59087e16833fdc03","fromNode":"7a62a94f79619a35","fromSide":"bottom","toNode":"c0275da77fdea6e4","toSide":"top"},
		{"id":"990e522badd3f091","fromNode":"fe3f148d79cee836","fromSide":"left","toNode":"c6a6832d131c714f","toSide":"top"},
		{"id":"b503efa9f456f177","fromNode":"c964a970e83085ce","fromSide":"right","toNode":"7a62a94f79619a35","toSide":"left"},
		{"id":"35fcbfb57fa584f9","fromNode":"7a62a94f79619a35","fromSide":"right","toNode":"2541e542989c91d9","toSide":"left"},
		{"id":"56036327ba8ba658","fromNode":"205ec53987630507","fromSide":"left","toNode":"c50ec3d92112a500","toSide":"top"},
		{"id":"50a57863337a08a7","fromNode":"fe3f148d79cee836","fromSide":"right","toNode":"c50ec3d92112a500","toSide":"top"},
		{"id":"c98ff18fd84835fa","fromNode":"205ec53987630507","fromSide":"right","toNode":"f0a65a0f8925ae99","toSide":"top"},
		{"id":"95b4763fdb59c73c","fromNode":"6c35a2c1b7d6d287","fromSide":"left","toNode":"f0a65a0f8925ae99","toSide":"top"},
		{"id":"f3e0234501208c8b","fromNode":"c35497d008015692","fromSide":"right","toNode":"4ff436ec173360a0","toSide":"left"},
		{"id":"544c230fb752247f","fromNode":"2541e542989c91d9","fromSide":"right","toNode":"c35497d008015692","toSide":"left"}
	]
}