{
	"nodes":[
		{"id":"2d66790d4a2012b5","type":"text","text":">[!success] Info general del modulo\n\n1. Este archivo tienen un `handler` para cada tipo de dispositivo, \n\t- `handleStatusConfInputAD20(...)`\n\t- `handleStatusConfInputAD20V3(...)`\nparsean el JSON de entrada, recorren `message.conf`, y según `conf.ref` llaman a lógica interna.\n\n2. Una serie de funciones internas de negocio (helpers privados tipo `_check...` [[TypeScript - Main Site#^36fb64]]),Además, a partir de ciertos parámetros genera efectos derivados (flags/valores/visibilidad de sondas, mute de alarmas, etc.) para que el sistema se comporte acorde. Normalmente no manda nada al dispositivo: sincroniza y ajusta el estado en BD y lógica del cloud.\n3. Funciones de soporte  que preparan y protegen el flujo, mientras los helpers implementan la lógica del dominio.; se encargan de que el micro pueda procesar mensajes de forma segura y consistente (parseo, validación mínima, inicialización, logs, manejo de errores).\n\n\t- `_initializeVariables()`\n\t- `_intializeVariables()` → prepara repositorios, parsers y servicios antes de procesar mensajes.\n\t- `_parseMessage(msg)` o un bloque `try { JSON.parse(msg) } catch { ... }` → convierte el string JSON a objeto y evita que el micro se caiga si viene mal formado.","x":-580,"y":-520,"width":680,"height":360},
		{"id":"222f360ae939fa72","type":"text","text":">[!success] Info general de un helper\n\ncuando un helper es llamado por un helper para hacer una comprobación en la base de datos como por ejemplo `handleStatusConfInputAD20 > _checkingEnableProbesAd20`... y hara un `get.model` este se repetira de diferentes maneras en distintos ***_helpers_***","x":440,"y":-430,"width":620,"height":180},
		{"id":"34664565fd224813","type":"text","text":">[!success] Info general del modulo\n","x":440,"y":-160,"width":620,"height":180},
		{"id":"36199fb2b29ef75e","type":"text","text":">[!success] info de un hanlde\n\n","x":440,"y":-700,"width":620,"height":180},
		{"id":"9cfb270bac18e411","type":"text","text":">[!question]\n\nTodos los micros extienden de la clase Microservice con lo que heredan el context [[AKO 44 - Flujo Registrar el Context.canvas]] del cual consiguen toda la info del device y del usuario ","x":440,"y":-980,"width":620,"height":200},
		{"id":"e0fc7fd79bc8285e","type":"text","text":">[!warning]\n\n `getModel` (Model Registry / Service Locator)\n\n- Pides el modelo por nombre: `this.getModel(\"device\")`.\n- Trabajas **directo con Mongoose** (`find`, `updateOne`, etc.) desde cada helper.\n- Ventaja: simple y rápido, menos capas.\n- Inconveniente: acceso a BD queda repartido y se repite; más difícil de testear/mantener.\n    \n Repository\n\n- Creas una clase `DeviceRepository` con métodos tipo `getById`, `setMute`, `setEnabledProbes`.\n- Los helpers llaman al repo y **no tocan Mongoose** directamente.\n- Ventaja: BD centralizada, menos duplicación, más testable, cambios en un solo sitio.\n- Inconveniente: más estructura/archivos, coste inicial de definir métodos.","x":1380,"y":-280,"width":620,"height":300},
		{"id":"3ad9b7d1c7623fc8","type":"text","text":">[!error] ¡Importante!\n\nBuscar mejores patrones de diseño y practicas para repositorios","x":1380,"y":-490,"width":620,"height":120}
	],
	"edges":[
		{"id":"ff72108129e7372c","fromNode":"2d66790d4a2012b5","fromSide":"right","toNode":"36199fb2b29ef75e","toSide":"left","label":"handleStatusConf.."},
		{"id":"c093a6741165cdb9","fromNode":"2d66790d4a2012b5","fromSide":"right","toNode":"222f360ae939fa72","toSide":"left","label":"_helpers"},
		{"id":"b8c0e43b88b36c52","fromNode":"2d66790d4a2012b5","fromSide":"right","toNode":"34664565fd224813","toSide":"left","label":"_soporte"},
		{"id":"ac1098d8b7fa6395","fromNode":"9cfb270bac18e411","fromSide":"bottom","toNode":"36199fb2b29ef75e","toSide":"top"},
		{"id":"dbe4b12c8f674a57","fromNode":"222f360ae939fa72","fromSide":"right","toNode":"e0fc7fd79bc8285e","toSide":"left"},
		{"id":"58c13463c8ac44d2","fromNode":"3ad9b7d1c7623fc8","fromSide":"bottom","toNode":"e0fc7fd79bc8285e","toSide":"top"}
	]
}