{
	"nodes":[
		{"id":"67d4c9ad91efa090","type":"text","text":">[!warning] Contexto del flujo \nCuando llega una petición HTTP a la API, Express la procesa con una cadena de “pasos”. Primero, un middleware crea `req.context` y, según los headers (authtoken/app token/apikey), valida quién es el usuario y rellena en ese contexto su empresa y permisos. Después, la petición cae en la ruta del controlador correspondiente; ahí se crea una instancia del controlador con ese `context` y se ejecuta el método (por ejemplo, enviar configuración). Antes de hacer nada sensible, el controlador consulta los permisos del contexto y, si están OK, realiza la acción y devuelve la respuesta al cliente.\n","x":-250,"y":-1620,"width":840,"height":260},
		{"id":"6c9cf137d05190b4","type":"text","text":"- Crea `req.context = new Context()` (un “contenedor” donde guardarán usuario, compañía, privilegios y flags de sesión).\n- Intenta detectar **cómo viene autenticada** la request mirando cabeceras/query/cookies:\n    - Si hay un token tipo usuario (`x-authtoken` / `x-publickey` / query / cookie), decide entre:\n        - **Application token session** (par de claves: `x-authtoken + x-application` o `x-publickey + x-privatekey`)\n        - **User session** (un token de usuario normal)\n    - Si no hay authToken pero sí `x-apikey`, crea **API key session**.\n    - Si no hay nada, deja la request como **sin contexto autenticado**.\n- Para cada caso llama a una función de validación que:\n    - verifica en Mongo,\n    - rellena `req.context` (user/company/privileges/flags),\n    - y luego hace `next()` para que continúe la request.\n- En el caso de `x-apikey`, si falla, **responde con error ahí mismo** (corta el flujo). En los otros casos, si falla normalmente hace `next()` igualmente (pero sin un contexto válido), y el control real lo acaba haciendo luego `_checkPrivilege()` en los controladores.\n![[Pasted image 20260219105610.png]]\n","x":-250,"y":-1240,"width":840,"height":340},
		{"id":"79f1ba39843cdead","type":"text","text":"Es el “contenedor” por request donde el middleware va guardando quién es el usuario, qué empresa tiene, qué permisos aplica, y flags de sesión (admin/app/apikey/system). Se crea al inicio de cada request y se rellena durante la validación de sesión antes de llegar a los controladores.\n```js\nexport class Context {\n  auth: any;                     // Info de autenticación “cruda” (modelo Auth, tokens, etc.)\n  private _user: any;            // Usuario resuelto para la request (se setea en _validateUserSession/_validateApiKeySession)\n  private _company: any;         // Compañía asociada a la request (idem)\n  private _privileges: any;      // Permisos efectivos (rights) que se usarán para autorizar acciones\n\n  isNewCompany: boolean;         // Flag que el middleware puede marcar (p.ej. si no hay devices todavía)\n  isAdminAppSession: boolean = false; // Flag para sesiones “admin app” (superadmin con query isAdminApp, etc.)\n  companies: Array<any> = [];    // Soporte para multi-company (si aplica en algún flujo)\n\n  deviceId: string;              // Campos auxiliares de contexto (se rellenan en algunos endpoints/flows)\n  remoteAddress: string;\n  isApiKeySession: boolean = false;   // Indica que la autenticación viene por x-apikey\n  isSystemContext: boolean = false;   // Indica que es un contexto “system” (sin usuario real)\n  constructor(req?: Request | any, isSystemContext: boolean = false) {\n    // Permite construir Context de dos maneras:\n    // - sin req: contexto vacío (luego se rellenará en middleware)\n    // - con req: “arranca” con algunos datos ya presentes en req (si los hubiera)\n    this.isSystemContext = isSystemContext;\n    // Si alguien crea Context pasándole un req que ya tiene auth, lo copia.\n    // (en tu _registerContext normalmente haces new Context() sin req)\n    if (req && req.auth) {\n      this.auth = req.auth;\n    }\n    // Igual para company: si ya venía en req, lo copia al Context.\n    if (req && req.company) {\n      this.company = req.company; // usa el setter (no mostrado aquí) para asignar _company\n    }\n  }\n}\n\n```\n","x":870,"y":-460,"width":840,"height":360},
		{"id":"699a669b5778f6cb","type":"text","text":"`Context` es un objeto “mochila” que se crea al inicio de cada request y se guarda en `req.context` para llevar usuario, empresa y permisos durante toda la petición.\n\nLa interfaz `Request extends express.Request { context: Context }` solo sirve para TypeScript: declara que `req` tendrá la propiedad `context` (autocompletado y sin errores), pero no la crea.\n\nQuien lo crea de verdad es el middleware (`req.context = new Context()`), y luego los controladores lo usan para validar permisos y acceder al usuario/compañía.\n\n```js\nexport interface Request extends express.Request {\ncontext: Context;\n}\n```","x":870,"y":-960,"width":863,"height":180},
		{"id":"e7913de14e7501cb","type":"text","text":"**registra un middleware global** y, por tanto, **se ejecuta en cada request** que entre app y este aplica a todas las rutas ya que esta definido antes que `_registerControllers()`\n```js\nreq.context = new Context();\nconst authToken = this._getAuthTokenByReq(req);\n```\n","x":-250,"y":-640,"width":840,"height":180},
		{"id":"4a682bccbecff08b","type":"text","text":"**`if (authToken && req.context)`**  \nSi la request trae **algún token de autenticación** (lo sacaste antes con `_getAuthTokenByReq`) y además ya existe `req.context`, entonces el sistema intenta autenticar **por sesión “normal”** (no por apikey).\n**`else if (req.headers[\"x-apikey\"])`**  \nSi no había `authToken`, pero sí hay `x-apikey`, entonces se intenta autenticar como **sesión por API Key** (otro mecanismo distinto).\n![[Pasted image 20260219113307.png]]\n","x":-250,"y":-290,"width":840,"height":220},
		{"id":"fd6aaabd142eaeff","type":"text","text":"Busca un token de autenticación en la request y lo devuelve. Primero revisa headers, luego query y por último cookies. Si no encuentra nada, devuelve `undefined` y la request seguirá sin contexto autenticado\n```js\nprivate _getAuthTokenByReq(req: Request): string {\n  let authToken;\n  // 1) Prioridad máxima: header \"x-authtoken\"\n  //    -> típico token de sesión/usuario en headers\n  if (req.headers[\"x-authtoken\"]) {\n    authToken = req.headers[\"x-authtoken\"];\n  }\n  // 2) Alternativa: header \"x-publickey\"\n  //    -> suele usarse cuando la auth es por par public/private key\n  else if (req.headers[\"x-publickey\"]) {\n    authToken = req.headers[\"x-publickey\"];\n  }\n  // 3) Alternativa: querystring \"?authtoken=...\"\n  //    -> útil para llamadas tipo GET desde navegador o enlaces\n  else if (req.query && req.query.authtoken) {\n    authToken = req.query.authtoken;\n  }\n  // 4) Alternativa: cookie \"authtoken\"\n  //    -> útil si el front guarda sesión en cookies\n  else if (req.cookies && req.cookies.authtoken) {\n    authToken = req.cookies.authtoken;\n  }\n  // Devuelve el token encontrado (o undefined si no hay en ningún sitio)\n  return authToken;\n}\n```\n","x":-1450,"y":-735,"width":840,"height":370},
		{"id":"52e9380f1974300c","type":"text","text":"/ Si existe un authToken (sacado de headers/query/cookies) y además ya tenemos req.context,\n// entonces intentamos autenticar la request usando \"token-based auth\" (usuario o aplicación).\n```js\nif (authToken && req.context) {\n```\n","x":-830,"y":280,"width":840,"height":127},
		{"id":"19da2a0b1b2ec47c","type":"text","text":"\n**IF (Application token context)**  \nSi la request trae un _par de credenciales_ (authtoken+application o publickey+privatekey), el backend la trata como una llamada “de aplicación” (no de un usuario humano). Valida ese par con `_validateApplicationTokenSession(req)` y, salga bien o mal, deja continuar la cadena de middlewares con `next()` (si falla, simplemente no se rellena el contexto como sesión válida).\n```js\n// IF: “Application token context”\nif (\n  (req.headers[\"x-authtoken\"] && req.headers[\"x-application\"]) ||\n  (req.headers[\"x-publickey\"] && req.headers[\"x-privatekey\"])\n) {\n  // Se interpreta la petición como credenciales de aplicación (par de claves).\n  this._validateApplicationTokenSession(req)\n    .then(() => next())\n    .catch(() => next());\n}\n\n```\n","x":-1450,"y":760,"width":840,"height":380},
		{"id":"c6d7851d6edd42da","type":"text","text":"Este bloque detecta requests autenticadas por API key (sin authToken de usuario). Si la API key es válida, se construye el `req.context` y se continúa; si no, se corta devolviendo error desde aquí.\n\n```js\nelse if (req.headers[\"x-apikey\"]) {\n  // Si la request trae cabecera x-apikey, intenta autenticarla como “API key session”\n  this._validateApiKeySession(req)\n    .then((req) => {\n      // Si es válida, deja pasar la request al siguiente middleware/controlador\n      return next();\n    })\n    .catch((err: any) => {\n      // Si falla, responde aquí mismo con error (no continúa la cadena)\n      res.statusCode = err.status ? err.status : 500;\n      return res.send(err);\n      // (alternativa comentada: next(err))\n    });\n}\n\n```\n","x":550,"y":280,"width":840,"height":380},
		{"id":"241e0dfb56ae6cbb","type":"text","text":"Autentica una request por `x-apikey`. Si existe la API key y su compañía, carga al usuario “owner” como identidad del contexto, aplica rate limit (contando requests recientes) y registra logs en `RateLimit` y `Debugger`. Si pasa todo, devuelve `req` para continuar el middleware.\n\n```js\nprivate _validateApiKeySession(req: Request): Promise<any> {\n\n  // Lee la API key desde cabecera\n  const key = req.headers[\"x-apikey\"];\n\n  // Busca esa key en la colección Apikey\n  return Apikey.findOne({ key: key })\n\n    // Trae la company asociada a esa key (si está activa)\n    .populate({\n      path: \"_company\",\n      select: \"_id name logo ownerUser alias rateLimit privileges acceptConditionId\",\n      match: { active: true }\n    })\n\n    .then((apiKey: any) => {\n\n      // Solo continúa si existe apikey, su company, y la company tiene ownerUser\n      if (apiKey && apiKey._company && apiKey._company.ownerUser) {\n\n        // Carga el usuario owner de la compañía (se usará como identidad “dueña” para el contexto)\n        return User.findOne({ _id: apiKey._company.ownerUser })\n          .then((userOwner: UserModel) => {\n\n            // Si no existe el owner, se considera inválido\n            if (!userOwner) {\n              return Promise.reject();\n            }\n\n            // Monta el contexto como “sesión por API key”\n            req.context.user = userOwner;\n            req.context.company = apiKey._company;\n            req.context.privileges = userOwner.privileges; // permisos del owner\n            req.context.auth = {};                         // no hay Auth de usuario\n            req.context.isApiKeySession = true;\n\n            // Marca última request de la API key\n            return Apikey.findByIdAndUpdate(\n              apiKey._id,\n              { $set: { lastRequestDate: new Date() } }\n            )\n            .then(() => {\n\n              // Rate limit: ventana de tiempo en segundos (default 60s)\n              const companyLimitTime =\n                apiKey._company.rateLimit ? apiKey._company.rateLimit.time : 60;\n\n              // Rate limit: nº máximo de requests (default 10), restando 1 por la actual\n              const companyLimitCount =\n                apiKey._company.rateLimit\n                  ? apiKey._company.rateLimit.count - 1\n                  : 10 - 1;\n\n              // A partir de aquí cuentan las requests “en los últimos N segundos”\n              const dateLimit = moment().subtract(companyLimitTime, \"seconds\");\n\n              // Cuenta cuántas requests recientes hay para esa apikey\n              return RateLimit.count({\n                apikey: apiKey.key,\n                dateLimit: { $gte: dateLimit.toDate() }\n              })\n              .then((countRequest: any) => {\n\n                // Si supera el límite -> error 420\n                if (countRequest !== 0 && countRequest > companyLimitCount) {\n                  return Promise.reject({\n                    status: 420,\n                    message: \"Rate Limit - too many requests.\"\n                  });\n                }\n\n                // Si no supera, registra la request en RateLimit (auditoría/control)\n                return RateLimit.create({\n                  apikey: apiKey.key,\n                  type: req.method,\n                  dateLimit: moment().add(companyLimitTime, \"seconds\").toDate(),\n                  dateRequest: new Date(),\n                  data: {\n                    header: req.headers,\n                    url: req.url,\n                    body: JSON.stringify(req.body),\n                    method: req.method\n                  }\n                })\n                .then(() => {\n                  // Devuelve req para que el middleware caller pueda seguir\n                  return Promise.resolve(req);\n                });\n              });\n            })\n            // Además, guarda un log de debugging (traza de request) para esa API key\n            .then(() => {\n              return Debugger.create({\n                model: (apiKey._company && apiKey._company) ? apiKey._company.name : apiKey._company,\n                serialNumber: apiKey.key,\n                type: \"apikey\",\n                data: {\n                  header: req.headers,\n                  url: req.url,\n                  body: JSON.stringify(req.body),\n                  method: req.method\n                },\n                date: new Date()\n              })\n              .then(() => {\n                return Promise.resolve(req);\n              });\n            });\n          })\n          // Errores buscando user owner / chain interna\n          .catch((err) => {\n            console.log(\"err1\", err);\n            return Promise.reject(err);\n          });\n      }\n      // OJO: si no se cumple el if, aquí no hay return explícito.\n      // En la práctica, acaba devolviendo undefined y la promesa se resuelve “vacía”.\n      // (lo normal sería: return Promise.reject() para tratarlo como inválido)\n    })\n    // Errores del findOne/populate, etc.\n    .catch((err) => {\n      console.log(\"err2\", err);\n      return Promise.reject(err);\n    });\n}\n\n```\n","x":1890,"y":280,"width":840,"height":380},
		{"id":"7cee088a02cfe64d","type":"text","text":">[!Error] Recuerda para cuando se hacen llamadas desde api...\n>","x":-1810,"y":520,"width":622,"height":82},
		{"id":"cf0f775078f89f06","type":"text","text":"\nValida un par de claves de “aplicación”. Si existe y está activo, actualiza `lastUse` y construye un `req.context` como usuario técnico `system` (con flags de sesión admin). Si no existe, rechaza la promesa.\n```js\nprivate _validateApplicationTokenSession(req: any): Promise<any> {\n  // Busca un ApplicationToken activo que coincida con el par (publicKey, privateKey)\n  // Permite dos nombres de cabecera según el tipo de cliente:\n  // - x-authtoken + x-application\n  // - x-publickey + x-privatekey\n  return ApplicationToken.findOne({\n    publicKey: req.headers[\"x-authtoken\"] || req.headers[\"x-publickey\"],\n    privateKey: req.headers[\"x-application\"] || req.headers[\"x-privatekey\"],\n    active: true\n  })\n    .lean() // devuelve objeto plano (no documento mongoose)\n    .then((appToken: ApplicationTokenModel) => {\n      // Si existe el token, se considera sesión válida de “aplicación”\n      if (appToken) {\n        // Actualiza la última vez que se ha usado el token\n        return ApplicationToken.updateOne(\n          { _id: appToken._id },\n          { lastUse: new Date() }\n        )\n        .then(() => {\n          // Rellena el contexto como “system”\n          // (no es un usuario real, es una identidad técnica)\n          req.context.user = {\n            username: \"system\",\n            name: \"system\",\n            isSuperadmin: true\n          }\n          // Marca flags de sesión “admin app”\n          req.context.isAdminAppSession = true;\n          // En este modo, normalmente no se cargan privilegios de usuario\n          req.context.privileges = [];\n          // Indica que el contexto es de sistema\n          req.context.isSystemContext = true;\n          // Context.auth vacío (no hay Auth de usuario)\n          req.context.auth = {};\n          // Devuelve la request para continuar el middleware chain\n          return Promise.resolve(req);\n        });\n      }\n      // Si no encuentra token, “fallo de autenticación”\n      return Promise.reject();\n    })\n    .catch((err) => {\n      console.log(\"ERROR :: Application Token not found\");\n      return Promise.reject(err);\n    });\n}\n\n```\n","x":-2730,"y":760,"width":840,"height":380},
		{"id":"c9325f00b9840827","type":"text","text":"**ELSE (User context)**  \nSi hay `authToken` pero no viene acompañado de ese “par de aplicación”, la request se trata como sesión normal de usuario. Entonces llama a `_validateUserSession(req, authToken)` para buscar el token en BD, cargar usuario/empresa/privilegios en `req.context` y luego continúa con `next()` (si falla, sigue pero sin contexto autenticado).\n```js\n// ELSE: “User context”\nelse {\n  // Se interpreta la petición como sesión de usuario (authToken normal).\n  this._validateUserSession(req, authToken)\n    .then(() => next())\n    .catch(() => next());\n}\n```\n","x":-760,"y":1280,"width":840,"height":380},
		{"id":"3bdd41a9acca06c3","type":"text","text":"Valida una sesión de usuario por `authToken` en la colección de Auth, carga usuario y company (si están activos), rellena `req.context` con auth/user/company/privilegios, ajusta dispositivos permitidos y marca si la empresa está “vacía” (sin dispositivos). Si falta algo, rechaza.\n```js\nprivate _validateUserSession(req: any, authToken: string): Promise<any> {\n\n  // Construye el filtro base para encontrar la sesión Auth por token\n  const authFilter: any = { authToken: authToken };\n\n  // Si piden \"isAdminApp\" por query, fuerza que la sesión venga de adminLogin\n  if (req.query && req.query.isAdminApp) {\n    authFilter.adminLogin = true;\n  }\n\n  // Busca el Auth (sesión) y trae el user y la company asociados\n  return Auth.findOne(authFilter)\n\n    // Carga el usuario (solo si está activo) y selecciona campos concretos\n    .populate({\n      path: \"user\",\n      select: \"_id _company username firstname lastname privileges isAdmin isSuperadmin isOwner language temperatureUnit exportCsvDelimiter numberFormat avatar imageUrl workSpace target allowedDevices allowedGroups targetTags targetModels exportEncoding sessionData privilegesGroups\",\n      match: { active: true }\n    })\n    // Carga la company (solo si está activa) y selecciona campos concretos\n    .populate({\n      path: \"_company\",\n      select: \"_id name logo imageUrl ownerUser alias privileges acceptConditionId\",\n      match: { active: true }\n    })\n    .then((auth: any) => {\n      // Si existe Auth y además user y company están presentes → sesión válida\n      if (auth && auth.user && auth._company) {\n        // Actualiza el “último uso” de la sesión\n        (<AuthModel>auth).lastUsedAt = Date.now();\n        auth.save();\n        // Si el usuario es superadmin y viene el flag isAdminApp → marca sesión admin app\n        if (auth.user.isSuperadmin && req.query.isAdminApp) {\n          req.context.isAdminAppSession = true;\n        }\n        // Mete en el contexto toda la info clave para autorización y lógica de negocio\n        req.context.auth = auth;\n        req.context.user = auth.user;\n        req.context.company = auth._company;\n        // Si viene un grupo por query, recalcula privilegios efectivos mezclando grupo + base\n        if (req.query && req.query.group) {\n          req.context.privileges = this._mergeGroupPrivileges(auth.user, req.query.group);\n        } else {\n          // Si no, usa los privilegios del usuario tal cual\n          req.context.privileges = auth.user.privileges;\n        }\n        // Calcula si el usuario es owner de la company\n        req.context.user.isOwner =\n          auth._company &&\n          auth._company.ownerUser &&\n          auth._company.ownerUser.equals(auth.user._id)\n            ? true\n            : false;\n        // Devuelve \"auth\" (ojo: no devuelve req aquí, devuelve auth)\n        return Promise.resolve(auth);\n      }\n      // Si no hay sesión válida, corta\n      return Promise.reject();\n    })\n    // Aplica filtros de \"allowedDevices/allowedGroups\" según workSpace/target/etc.\n    .then(() => {\n      return this._setAllowedDevices(req);\n    })\n    // Comprueba si la company es “nueva” (si no tiene devices)\n    .then((req: any) => {\n      return Device.getTotal({\n        filter: { _company: req.context.company._id }\n      })\n      .then((deviceCount: number) => {\n        if (deviceCount === 0) {\n          req.context.isNewCompany = true;\n        }\n        return Promise.resolve();\n      });\n    })\n    // Termina OK\n    .then(() => {\n      return Promise.resolve();\n    })\n    // Propaga error\n    .catch((err) => {\n      return Promise.reject(err);\n    });\n}\n\n```\n","x":580,"y":1230,"width":840,"height":480}
	],
	"edges":[
		{"id":"464c27c51b122b19","fromNode":"67d4c9ad91efa090","fromSide":"bottom","toNode":"6c9cf137d05190b4","toSide":"top","label":"app.ts"},
		{"id":"4e0a0b4071893a7a","fromNode":"6c9cf137d05190b4","fromSide":"bottom","toNode":"e7913de14e7501cb","toSide":"top","label":"_registerContext"},
		{"id":"4c22c5c9c9cd6890","fromNode":"e7913de14e7501cb","fromSide":"right","toNode":"79f1ba39843cdead","toSide":"left","label":"Context( )"},
		{"id":"eead17d5e7f604bf","fromNode":"e7913de14e7501cb","fromSide":"right","toNode":"699a669b5778f6cb","toSide":"left","label":"req.context"},
		{"id":"a26daffa393f7664","fromNode":"e7913de14e7501cb","fromSide":"left","toNode":"fd6aaabd142eaeff","toSide":"right","label":"_getAuthTokenByReq"},
		{"id":"e65ef72a5855f079","fromNode":"e7913de14e7501cb","fromSide":"bottom","toNode":"4a682bccbecff08b","toSide":"top"},
		{"id":"02cd862aa4285946","fromNode":"4a682bccbecff08b","fromSide":"bottom","toNode":"52e9380f1974300c","toSide":"top","label":"if"},
		{"id":"82be5cef3120ad8e","fromNode":"4a682bccbecff08b","fromSide":"bottom","toNode":"c6d7851d6edd42da","toSide":"top","label":"else"},
		{"id":"5f235d7f00ed637a","fromNode":"19da2a0b1b2ec47c","fromSide":"right","toNode":"c9325f00b9840827","toSide":"top","label":"else"},
		{"id":"416b4586731598d5","fromNode":"c9325f00b9840827","fromSide":"right","toNode":"3bdd41a9acca06c3","toSide":"left","label":"_validateUserSession"},
		{"id":"29f5c2bd1d143a72","fromNode":"19da2a0b1b2ec47c","fromSide":"top","toNode":"7cee088a02cfe64d","toSide":"bottom"},
		{"id":"4e7e2cb2bc8b0abe","fromNode":"19da2a0b1b2ec47c","fromSide":"left","toNode":"cf0f775078f89f06","toSide":"right","label":"_validateApplicationTokenSession"},
		{"id":"388c3c3a185ea988","fromNode":"c6d7851d6edd42da","fromSide":"right","toNode":"241e0dfb56ae6cbb","toSide":"left","label":"_validateApiKeySession"},
		{"id":"cfb4f0c1c226e242","fromNode":"52e9380f1974300c","fromSide":"bottom","toNode":"19da2a0b1b2ec47c","toSide":"top"}
	]
}