{
	"nodes":[
		{"id":"48300c02ca37240c","x":-391,"y":-503,"width":891,"height":623,"type":"text","text":"```js\nconst amqp = require('amqplib');\n\nconst { c } = require('tar');\n\n  \n\nasync function main() {\n\n// Leer el número de mensajes y el delay (ms) desde los argumentos de línea de comandos\n\n// Uso: node pub.js <numero_de_mensajes> [minidelay_ms]\n\nif (!process.argv[2]) {\n\nconsole.error('Error: Debes proporcionar el número de mensajes');\n\nconsole.error('Uso: node pub.js <numero_de_mensajes> [minidelay_ms]');\n\nconsole.error('Ejemplo: node pub.js 5000 10');\n\nprocess.exit(1);\n\n}\n\n  \n\nconst numMessages = parseInt(process.argv[2], 10);\n\nconst minDelayMs = process.argv[3] ? parseInt(process.argv[3], 10) : 100;\n\n  \n\nif (isNaN(numMessages) || numMessages <= 0) {\n\nconsole.error('Error: El número de mensajes debe ser un número positivo');\n\nconsole.error('Ejemplo: node pub.js 5000 10');\n\nprocess.exit(1);\n\n}\n\nif (isNaN(minDelayMs) || minDelayMs < 0) {\n\nconsole.error('Error: minidelay_ms debe ser un número entero >= 0');\n\nconsole.error('Ejemplo: node pub.js 5000 10');\n\nprocess.exit(1);\n\n}\n\n  \n\nconsole.log(\n\n`Generando ${numMessages} mensajes (minidelay=${minDelayMs} ms)...`\n\n);\n\n  \n\nconst connection = await amqp.connect('amqp://localhost');\n\nconst channel = await connection.createChannel();\n\nconst exchange = 'akocloud';\n\nconst routingKey = 'driver.input.perte';\n\n  \n\nawait channel.assertExchange(exchange, 'topic', { durable: true });\n\n  \n\nconst baseDeviceInformation = {\n\nserialNumber: 974130021,\n\ndevice: {\n\n_id: '6989bc8e59e52a4bafd618a9',\n\n_companyId: '5ab8a13370f53c000bc46384',\n\ncommercialVersion: 'AKO-D14123N',\n\nfirmwareVersion: 6402,\n\ndeviceDefinition: '6981e314cc2593f5137d03e4',\n\nmodemModel: 'Quectel_BC660K-GL',\n\ncreated_at: '2025-04-15T08:15:08.853Z',\n\nmodel: 'panel_1ry_6402',\n\nip: '10.10.2.201',\n\n},\n\nexistsInDevice: true,\n\nexistsInManufactured: true,\n\nlicense: true,\n\nuuid: '2E19CFDA300B3F385A343536754B33324B572E7E',\n\n};\n\n  \n\nconst baseInfo = { address: '10.10.2.201' };\n\n  \n\n// Generar payloads según el número especificado\n\nconst payloads = [];\n\nconst nowInSeconds = Math.floor(Date.now() / 1000);\n\nconst FIVE_MINUTES = 5 * 60 * 1000; // 5 minutos en MILISEGUNDOS\n\n  \n\nconsole.log(\n\n`Timestamp inicial: ${nowInSeconds} (${new Date(\n\nnowInSeconds * 1000\n\n).toISOString()})`\n\n);\n\n  \n\nfor (let i = 0; i < numMessages; i++) {\n\nconst timestamp = nowInSeconds - i * 300; // retroceder 5 minutos cada vez (300 segundos)\n\n// Generar valores distribuidos: 50% entre 0-2, 25% < -3, 25% > 3\n\nconst rand = Math.random();\n\nlet temp1, temp2;\n\n  \n\nif (rand < 0.5) {\n\n// 50% entre 0 y 2\n\ntemp1 = Math.floor(Math.random() * 20); // 0.0°C - 2.0°C (multiplicado por 10)\n\ntemp2 = Math.floor(Math.random() * 20); // 0.0°C - 2.0°C\n\n} else if (rand < 0.75) {\n\n// 25% menor que -3\n\ntemp1 = Math.floor(-30 - Math.random() * 50); // -3.0°C a -8.0°C\n\ntemp2 = Math.floor(-30 - Math.random() * 50);\n\n} else {\n\n// 25% mayor que 3\n\ntemp1 = Math.floor(30 + Math.random() * 70); // 3.0°C a 10.0°C\n\ntemp2 = Math.floor(30 + Math.random() * 70);\n\n}\n\n  \n\nconst temp3 = 0;\n\n  \n\nconst d1_val = 1;\n\nconst d2_val = i % 2;\n\nconst d3_val = Math.random() > 0.5 ? 1 : 0;\n\nconst d4_val = Math.random() > 0.5 ? 1 : 0;\n\nconst d5_val = Math.random() > 0.5 ? 1 : 0;\n\nconst d6_val = Math.random() > 0.5 ? 1 : 0;\n\nconst d1_cnt = 0;\n\nconst d2_cnt = 0;\n\nconst d3_cnt = Math.floor(Math.random() * 6);\n\nconst d4_cnt = Math.floor(Math.random() * 6);\n\nconst d5_cnt = Math.floor(Math.random() * 6);\n\nconst d6_cnt = Math.floor(Math.random() * 6);\n\npayloads.push({\n\nid: [2026200100007, 6402, 1, 26, 0],\n\nty: 'sample',\n\nli: 1,\n\nd: [[timestamp, temp1, 1, 1, temp2, 2, 1, temp3, 1, 1]],\n\nd1: [\n\n[\n\ntimestamp,\n\nd1_val,\n\nd1_cnt,\n\nd2_val,\n\nd2_cnt,\n\nd3_val,\n\nd3_cnt,\n\nd4_val,\n\nd4_cnt,\n\nd5_val,\n\nd5_cnt,\n\nd6_val,\n\nd6_cnt,\n\n],\n\n],\n\n});\n\n}\n\n  \n\nfor (let i = 0; i < payloads.length; i++) {\n\nconst message = {\n\ndeviceInformation: baseDeviceInformation,\n\npayload: payloads[i],\n\ninfo: baseInfo,\n\n};\n\n  \n\nchannel.publish(exchange, routingKey, Buffer.from(JSON.stringify(message)));\n\n  \n\nif (minDelayMs > 0) {\n\n// esperar el tiempo configurado entre mensajes\n\nawait new Promise((resolve) => setTimeout(resolve, minDelayMs));\n\n}\n\n  \n\n// actualizar progreso en la misma línea: \"sended x/total\"\n\nprocess.stdout.write(`\\rsended ${i + 1}/${payloads.length}`);\n\n  \n\n// log periódico en consola cada 1000 para registro persistente\n\nif ((i + 1) % 1000 === 0) {\n\nconsole.log(`\\nPublicados ${i + 1} de ${payloads.length} mensajes...`);\n\nprocess.stdout.write(`\\rsended ${i + 1}/${payloads.length}`);\n\n}\n\n}\n\n  \n\nawait channel.close();\n\nawait connection.close();\n\n// asegurarse de terminar la línea de progreso\n\nprocess.stdout.write('\\n');\n\nconsole.log(`Todos los ${payloads.length} mensajes han sido publicados.`);\n\n}\n\n  \n\nmain().catch((error) => {\n\nconsole.error(`An error occurred: ${error.message}`);\n\n});\n```"}
	],
	"edges":[]
}