{
	"nodes":[
		{"id":"604008fad8fe75d2","type":"text","text":"Define el micro “translator”: guarda sus dependencias (validador, procesador, mapa de rutas y servicio de parámetros). En el constructor se inicializa el micro base (donde suele estar la conexión/config común) y se prepara el procesador y el mapa que usará para enrutar mensajes al resto de micros.\n\n```js\nexport class TranslatorPerte extends Microservice {\n  // Identificador/nombre lógico del microservicio (útil para logs/config)\n  private _serviceName: string = \"translator.perte\";\n  // Servicio que valida que el mensaje y su payload tengan estructura/esquema correcto\n  private inputValidator: InputValidator;\n  // Servicio que parsea/normaliza el payload a un formato interno del cloud\n  private inputProcessor: InputProcessor;\n  // Mapa “tipo de mensaje → routing key/topic interno” para enrutar al micro especialista\n  private topicMap: Map<MessageType, string>;\n  // Servicio para gestionar mensajes de parámetros (pendientes, confirmaciones, reenvíos)\n  private paramMsgService: ParamMsgService;\n  constructor(dirname?: string) {\n    // Llama al constructor del Microservice base.\n    // Ahí es donde típicamente se carga config, logger, conexión a Rabbit, bindings, etc.\n    super(dirname || __dirname);\n    // Inicializa el procesador de mensajes (transformación semántica del payload)\n    this.inputProcessor = new InputProcessor();\n    // Carga el mapa de rutas: según el tipo de mensaje, a qué topic/routing key se publica\n    this.topicMap = TopicMap;\n  }\n}\n```","x":-172,"y":-160,"width":712,"height":420},
		{"id":"4ca5c9cbbac50c29","type":"text","text":"- El **translator recibe `msg` como texto** (string) porque Rabbit transporta el contenido como bytes/string y vuestro framework lo entrega como string.\n- `JSON.parse(msg)` es el paso que lo convierte en un **objeto** con la estructura `ClOutgoingMessage`:\n\n```js\npublic async handleInput(msg: string): Promise<any> {\n  // Log: muestra el mensaje tal como llega (normalmente un string JSON desde Rabbit)\n  this.log(LogLevels.INFO, \"Received message :: \" + msg);\n  // Aquí se guardará el mensaje ya convertido a objeto JS con la forma esperada\n  let parsedMsg: ClOutgoingMessage;\n  try {\n    // Convierte el string JSON `msg` en un objeto JavaScript.\n    // Si `msg` no es un JSON válido, esto lanza un error (SyntaxError).\n    parsedMsg = JSON.parse(msg);\n  } catch (error) {\n    // Si falla el parseo, loguea el error y abandona (no procesa nada más)\n    this.log(LogLevels.ERROR, \"Failed to parse message :: \" + error);\n    return Promise.resolve();\n  }\n  // ...a partir de aquí, parsedMsg debería tener:\n  // {\n  //   deviceInformation: {...},\n  //   payload: {...}\n  // }\n}\n```","x":-172,"y":400,"width":712,"height":420},
		{"id":"bdc74a44db836974","type":"text","text":"Cuando Rabbit entrega un mensaje por esa suscripción, el framework **invoca `handleInput`**, y ahí es donde “se activa” la lógica del translator.","x":-172,"y":-380,"width":712,"height":119},
		{"id":"1b2a11b7be379ccf","type":"text","text":"- Es un **filtro rápido** (“sanity check”) para asegurarse de que lo que llegó parece un `ClOutgoingMessage`.\n- No valida el contenido profundo del payload; solo confirma que:\n    - hay un `deviceInformation` “mínimamente” correcto\n    - existe la propiedad `payload`\n- Si no pasa, el translator **lo descarta** y registra error.\n- \n```js\nif (!this.isValidClOutgoingMessage(parsedMsg)) {\n  // Si el objeto parseado NO tiene la estructura mínima esperada,\n  // lo considera un mensaje inválido para este micro.\n  this.log(\n    LogLevels.ERROR,\n    \"WRONG ClOutgoingMessage structure :: \" + msg\n  );\n  // Corta el flujo: no valida schema, no procesa, no publica nada.\n  return Promise.resolve();\n}\n```","x":-616,"y":1020,"width":712,"height":400},
		{"id":"8e426203dde922eb","type":"text","text":"- Es un **filtro rápido** (“sanity check”) para asegurarse de que lo que llegó parece un `ClOutgoingMessage`.\n- No valida el contenido profundo del payload; solo confirma que:\n    - hay un `deviceInformation` “mínimamente” correcto\n    - existe la propiedad `payload`\n- Si no pasa, el translator **lo descarta** y registra error.\n\n```js\nthis.initializeInputValidator();\n```","x":-616,"y":1560,"width":712,"height":260},
		{"id":"e500ff46b0c3bd2d","type":"text","text":"- Hace “arranque perezoso”: si todavía no existen, crea y deja listos los servicios necesarios para el flujo.\n- `InputValidator` se apoya en la definición del dispositivo (en BD) para validar mensajes.\n- `ParamMsgService` prepara la parte de “params” (guardar pendientes / confirmar ACK / reenviar).\n```js\nthis.initializeInputValidator();\n\nprivate initializeInputValidator(): void {\n  // Inicializa el validador SOLO una vez (lazy init).\n  if (!this.inputValidator) {\n    this.log(LogLevels.INFO, \"Initializing InputValidator...\");\n\n    // Obtiene el modelo de Mongo/Mongoose \"deviceDefinition\"\n    const deviceDefinitionModel: Model<DeviceDefinitionModel> =\n      this.getModel(\"deviceDefinition\");\n\n    // Crea un repositorio para consultar device definitions\n    const deviceDefinitionRepo = new DeviceDefinitionRepository(\n      deviceDefinitionModel\n    );\n\n    // Crea el validador usando el repo (para validar según modelo/firmware/definición)\n    this.inputValidator = new InputValidator(deviceDefinitionRepo);\n\n    this.log(LogLevels.INFO, \"InputValidator initialized successfully.\");\n  }\n  // Inicializa el servicio de params SOLO una vez (lazy init).\n  if (!this.paramMsgService) {\n    this.log(LogLevels.INFO, \"Initializing ParamMsgService...\");\n    // Obtiene el modelo de Mongo/Mongoose \"paramMsg\"\n    const paramMsgModel: Model<ParamMsgModel> =\n      this.getModel(\"paramMsg\");\n    // Crea el servicio que gestiona params pendientes/confirmaciones\n    this.paramMsgService = new ParamMsgService(paramMsgModel);\n    this.log(LogLevels.INFO, \"ParamMsgService initialized successfully.\");\n  }\n}\n\n```","x":-1640,"y":1560,"width":712,"height":400},
		{"id":"dcd56c080800b1c3","type":"text","text":"Este bloque llama al validador para comprobar que el mensaje entrante es aceptable. La validación puede incluir compatibilidad de firmware y que el payload tenga el formato esperado. Si falla, el translator descarta el mensaje inmediatamente y lo deja registrado. Si pasa, el flujo continúa con la garantía de que el mensaje tiene una estructura válida y un tipo reconocido.\n```js\n// Pide al InputValidator que valide el mensaje entrante.\n// Es async porque puede hacer consultas (p.ej. revisar firmware/versiones en BD).\nconst validationResult = await this.inputValidator.validateMessage(parsedMsg);\n// Si el validador dice que NO es válido, se corta el flujo aquí:\n// - se registra un warning\n// - no se procesa el mensaje (no se parsea ni se publica a otros micros)\nif (!validationResult.isValid) {\n  this.log(\"warn\", \"WRONG Message\" + msg);\n  return Promise.resolve();\n}\n// Si pasa, a partir de aquí el flujo continúa con un mensaje válido\n// y normalmente con el tipo identificado (validationResult.messageType).\n\n```","x":-616,"y":2000,"width":712,"height":260},
		{"id":"e49100feff2d3468","type":"text","text":"\n```js\nprivate isValidClOutgoingMessage(msg: unknown): msg is ClOutgoingMessage {\n  return (\n    // 1) que exista (no null/undefined)\n    msg &&\n    // 2) que sea un objeto (y no un número/string/boolean)\n    typeof msg === \"object\" &&\n    // 3) que tenga un deviceInformation con estructura mínima válida\n    this.isValidDeviceInformation((msg as ClOutgoingMessage).deviceInformation) &&\n    // 4) que tenga la propiedad payload (no comprueba tipo ni contenido, solo que exista)\n    \"payload\" in msg\n  );\n}\n```","x":540,"y":1020,"width":712,"height":400},
		{"id":"d29a6fad46a8e608","type":"text","text":"Esta función prepara dependencias “lazy” (solo la primera vez). Si aún no existe, crea el validador de entrada y le pasa acceso a definiciones de dispositivo para poder validar firmware y schemas. Además inicializa el servicio de mensajes de parámetros para gestionar PARAM/PARAM_ACK. En llamadas siguientes no recrea nada, reutiliza las instancias ya creadas.\n\n```js\nprivate initializeInputValidator(): void {\n  // Si todavía NO existe this.inputValidator (primera vez que llega un mensaje)...\n  if (!this.inputValidator) {\n    // Log de que se va a inicializar\n    this.log(LogLevels.INFO, \"Initializing InputValidator...\");\n    // 1) Pide a la capa base (Microservice) el modelo de Mongoose \"deviceDefinition\"\n    //    -> esto conecta con la colección correspondiente en Mongo\n    const deviceDefinitionModel: Model<DeviceDefinitionModel> =\n      this.getModel(\"deviceDefinition\");\n    // 2) Construye un repositorio alrededor del modelo (patrón repositorio)\n    //    -> así InputValidator no accede directo a Mongoose\n    const deviceDefinitionRepo = new DeviceDefinitionRepository(deviceDefinitionModel);\n    // 3) Crea el InputValidator y le inyecta el repositorio\n    //    -> por eso luego puede buscar firmwareVersion en device definitions si falta en el mensaje\n    //    -> y aquí es donde, en su constructor, carga los schemas en schemaMap\n    this.inputValidator = new InputValidator(deviceDefinitionRepo)\n    // Log de OK\n    this.log(LogLevels.INFO, \"InputValidator initialized successfully.\");\n  // Si todavía NO existe this.paramMsgService (primera vez), lo inicializa también\n  if (!this.paramMsgService) {\n    this.log(LogLevels.INFO, \"Initializing ParamMsgService...\");\n    // 1) Pide el modelo de Mongoose \"paramMsg\"\n    const paramMsgModel: Model<ParamMsgModel> = this.getModel(\"paramMsg\");\n    // 2) Cre el servicio que gestiona PARAM/PARAM_ACK (guardar pendientes, confirmar, etc.)\n    this.paramMsgService = new ParamMsgService(paramMsgModel);\n    this.log(LogLevels.INFO, \"ParamMsgService initialized successfully.\");\n  }\n}\n\n```","x":420,"y":1560,"width":712,"height":260},
		{"id":"f7a890c172ae9e0a","type":"text","text":">[!info] Concepto lazy\n\n- `if (!this.inputValidator) { ... }` ⇒ **solo lo crea la primera vez** que llega un mensaje.\n- En los siguientes mensajes, como ya existe, **no lo vuelve a crear** y se reutiliza.\nVentajas típicas:\n- Arranca más rápido.\n- No creas conexiones/objetos si el micro nunca llega a procesar mensajes.\n- Evitas repetir trabajo y estados (como `schemaMap`) en cada mensaje.","x":1600,"y":1560,"width":772,"height":258},
		{"id":"6a3762a54906e35e","type":"text","text":">[!warning] InputValidator workFlow\n>Enlace a página [[AKO 44  - Driver Translator Perte - InputValidator workFlow.canvas]]","x":580,"y":2082,"width":712,"height":96},
		{"id":"6e961e4a6436b4b4","type":"text","text":"Este bloque toma un mensaje ya validado y lo envía al componente que lo “traduce” a un formato procesado (ParserOutput) para el resto del sistema. Se le indica además el contexto/origen del procesamiento (entrada). Si el parseo falla y devuelve `null`, el translator no publica nada y termina aquí. Esto evita propagar datos incompletos o mal interpretados a los micros posteriores.\n```js\n// Una vez validado el mensaje (firmware + schema + tipo),\n// se pasa al \"procesador\" que lo transforma al formato interno que usan los otros micros.\nconst processedMessage = await this.processMessage(\n  parsedMsg,                 // mensaje original (deviceInformation + payload)\n  validationResult,          // resultado de validación (incluye messageType)\n  ProcessMethod.INPUT        // indica que viene de entrada (desde CoAP/driver)\n);\n// Si el procesador devuelve null/undefined, significa que NO se pudo parsear/transformar.\n// En ese caso se corta el flujo: no se publica nada a otros micros.\nif (!processedMessage) {\n  this.log(LogLevels.WARN, \"processedMessage is null\");\n  return Promise.resolve();\n}\n```","x":-616,"y":2400,"width":712,"height":260},
		{"id":"d25a4c934a7a1fb9","x":580,"y":2400,"width":712,"height":260,"type":"text","text":"Es una etiqueta estándar para enrutar el procesamiento. En vez de tener cuatro funciones separadas llamadas “a mano”, se pasa un `ProcessMethod` y el `switch` elige la ruta correcta. Esto hace el flujo más uniforme y evita duplicar lógica.\n\n```js\nexport enum ProcessMethod {\n  \"BACKLOG\" = \"backlog\",\n  \"COMMAND\" = \"command\",\n  \"INPUT\" = \"input\",\n  \"PARAM\" = \"param\"\n}\n```"},
		{"id":"8ac8550e24a3946e","type":"text","text":"Este bloque detecta cuando el mensaje entrante es una confirmación de parámetros. En vez de publicar el mensaje como “dato” para otros micros, lo usa para actualizar el estado de un parámetro pendiente (confirmarlo). Si la confirmación falla, se loguea el error y se detiene el procesamiento. Esto evita que un ACK se trate como telemetría normal.\n```js\n// Caso especial: si el tipo de mensaje validado es PARAM_ACK\n// (acknowledgement de un \"param\" enviado previamente al dispositivo)\nif (validationResult.messageType === MessageType.PARAM_ACK) {\n  // Log informativo: este mensaje no se trata como telemetría normal,\n  // sino como una confirmación de que un parámetro fue recibido/aplicado.\n  this.log(\n    LogLevels.INFO,\n    \"Received PARAM_ACK message, just confirming param.\"\n  );\n  try {\n    // Marca/actualiza el estado del parámetro pendiente como confirmado.\n    // Normalmente esto implica tocar Mongo (colección paramMsg o similar)\n    // para cerrar la “tarea”/mensaje pendiente.\n    await this.paramMsgService.confirmParam(processedMessage);\n  } catch (error) {\n    // Si falla la confirmación (BD, lógica, etc.), se registra el error\n    // y se corta el flujo para no seguir publicando nada incorrecto.\n    this.log(\n      LogLevels.ERROR,\n      \"Failed to confirm param: \" + error.message\n    );\n    return Promise.resolve();\n  }\n  // (Fuera del snippet, normalmente aquí terminaría el handleInput para PARAM_ACK)\n}\n```","x":-1140,"y":2880,"width":712,"height":260},
		{"id":"495eeebd0ec354ec","type":"text","text":"Si el mensaje no es un ACK de parámetros, el translator primero comprueba si hay algún parámetro pendiente para ese dispositivo y, si lo hay, lo reenvía hacia el driver para intentar entregarlo de nuevo. Después publica el mensaje procesado al tópico correspondiente según el tipo (event/sample/status/etc.), para que lo consuma el micro especializado. Finalmente termina la ejecución del handler.\n```js\nelse {\n  // Para cualquier mensaje que NO sea PARAM_ACK:\n  // 1) Mira si existe algún \"param\" pendiente asociado a este dispositivo.\n  //    (Ej: se envió un param antes, pero el dispositivo aún no lo ha confirmado.)\n  const resendParam = await this.paramMsgService.getPendingParamMessage(\n    parsedMsg.deviceInformation\n  );\n  // 2) Si hay un param pendiente, lo reenvía al driver CoAP para que vuelva a intentarse.\n  //    Esto es una mecánica de “retry”/“resend” de parámetros.\n  if (resendParam != null) {\n    this.log(LogLevels.INFO, \"Resending pending param message.\");\n    // Publica hacia el canal de salida al dispositivo (driver CoAP)\n    this.sendEvent(\"cl.output.perte.coap.driver\", resendParam);\n  }\n  // 3) Publica el mensaje ya procesado al tópico final según su tipo (event, sample, status, etc.)\n  //    Esto lo enruta al micro especializado (event updater, sample updater, etc.)\n  this.publishParsedData(validationResult.messageType, processedMessage);\n}\n// 4) Termina el handler\nreturn Promise.resolve();\n```","x":40,"y":2880,"width":712,"height":260},
		{"id":"20651ddbb4f98b01","type":"text","text":"`processMessage` es un “router” interno de procesamiento. Crea un repositorio de definiciones de dispositivo para que el parser pueda consultar metadata si la necesita. Luego, según el `ProcessMethod`, llama al método correcto del `InputProcessor` (entrada, backlog, comandos o params). Si el método no existe o hay un error, devuelve `null`. En `handleInput`, si devuelve `null`, se corta el flujo para no publicar nada inválido.\n\n```js\nprivate async processMessage(\n  parsedMsg:\n    | ClOutgoingMessage\n    | BacklogOutgoingMessage\n    | ApiOutgoingCMDMessage\n    | ApiOutgoingParamMessage,\n  validationResult: { isValid: boolean; messageType?: MessageType },\n  processMethod: ProcessMethod\n): Promise<ParserOutput> {\n  try {\n    // Prepara un repo para poder leer definiciones del dispositivo (pv, mapeos, etc.)\n    // durante el parseo (por si el parser necesita datos de la deviceDefinition).\n    const deviceDefinitionModel: Model<DeviceDefinitionModel> =\n      this.getModel(\"deviceDefinition\");\n    const deviceDefinitionRepo = new DeviceDefinitionRepository(deviceDefinitionModel);\n    // Selecciona “qué pipeline de procesamiento” usar según el origen/flujo del mensaje\n    switch (processMethod) {\n      case ProcessMethod.BACKLOG:\n        // Mensajes que vienen de un backlog/replay\n        return await this.inputProcessor.processMessage(\n          parsedMsg as BacklogOutgoingMessage,\n          validationResult.messageType,     // tipo ya detectado/validado (event, sample, etc.)\n          deviceDefinitionRepo\n        );\n      case ProcessMethod.COMMAND:\n        // Mensajes que vienen del API de comandos (output command)\n        return await this.inputProcessor.processCommand(\n          parsedMsg as ApiOutgoingCMDMessage,\n          validationResult.messageType,\n          deviceDefinitionRepo\n        );\n      case ProcessMethod.INPUT:\n        // Mensajes que vienen “desde el dispositivo” (driver -> translator)\n        return await this.inputProcessor.processMessage(\n          parsedMsg as ClOutgoingMessage,\n          validationResult.messageType,\n          deviceDefinitionRepo\n        );\n      case ProcessMethod.PARAM:\n        // Mensajes de parámetros (param / param_ack) gestionados como pipeline específico\n        return await this.inputProcessor.processParam(\n          parsedMsg as ApiOutgoingParamMessage,\n          validationResult.messageType,\n          deviceDefinitionRepo\n        );\n      default:\n        // Si llega un método no contemplado, log y null para cortar el flujo\n        this.log(LogLevels.ERROR, `Unknown process method: ${processMethod}`);\n        return null;\n    }\n  } catch (error) {\n    // Si algo falla (model/repo/processor), se registra y se devuelve null\n    this.log(LogLevels.ERROR, \"Failed to get device definition model:\" + error);\n    return null;\n  }\n}\n```","x":-1720,"y":2400,"width":712,"height":260}
	],
	"edges":[
		{"id":"668b5a78bbea22a4","fromNode":"bdc74a44db836974","fromSide":"bottom","toNode":"604008fad8fe75d2","toSide":"top"},
		{"id":"c409f6bad075076d","fromNode":"604008fad8fe75d2","fromSide":"bottom","toNode":"4ca5c9cbbac50c29","toSide":"top"},
		{"id":"71c527ba6bf30928","fromNode":"1b2a11b7be379ccf","fromSide":"right","toNode":"e49100feff2d3468","toSide":"left","label":"isValidClOutgoingMessage"},
		{"id":"6fa27e074b7a00fa","fromNode":"4ca5c9cbbac50c29","fromSide":"bottom","toNode":"1b2a11b7be379ccf","toSide":"top"},
		{"id":"451898b11fada039","fromNode":"8e426203dde922eb","fromSide":"left","toNode":"e500ff46b0c3bd2d","toSide":"right"},
		{"id":"ce73dff88a591fd5","fromNode":"1b2a11b7be379ccf","fromSide":"bottom","toNode":"8e426203dde922eb","toSide":"top"},
		{"id":"832697f18dba149f","fromNode":"8e426203dde922eb","fromSide":"bottom","toNode":"dcd56c080800b1c3","toSide":"top"},
		{"id":"247afec05dcffe4b","fromNode":"dcd56c080800b1c3","fromSide":"right","toNode":"6a3762a54906e35e","toSide":"left","label":"validateMessage"},
		{"id":"520d1800443b0bc1","fromNode":"8e426203dde922eb","fromSide":"right","toNode":"d29a6fad46a8e608","toSide":"left","label":"initializeInputValidator"},
		{"id":"0fccef7ab6231619","fromNode":"d29a6fad46a8e608","fromSide":"right","toNode":"f7a890c172ae9e0a","toSide":"left","label":"Concepto lazy"},
		{"id":"6fa40f1ccfeb4377","fromNode":"dcd56c080800b1c3","fromSide":"bottom","toNode":"6e961e4a6436b4b4","toSide":"top"},
		{"id":"191955dc8495fe43","fromNode":"6e961e4a6436b4b4","fromSide":"right","toNode":"d25a4c934a7a1fb9","toSide":"left","label":"ProcessMethod"},
		{"id":"5d7cfc3a5daa0cdd","fromNode":"6e961e4a6436b4b4","fromSide":"bottom","toNode":"8ac8550e24a3946e","toSide":"top","label":"if"},
		{"id":"ba137489d6f1079a","fromNode":"6e961e4a6436b4b4","fromSide":"bottom","toNode":"495eeebd0ec354ec","toSide":"top","label":"else"},
		{"id":"078912eb0140a270","fromNode":"6e961e4a6436b4b4","fromSide":"left","toNode":"20651ddbb4f98b01","toSide":"right","label":"processMessage"}
	]
}