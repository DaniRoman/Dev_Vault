{
	"nodes":[
		{"id":"84a2af9260a643d8","type":"text","text":">[!Success] Funcionamiento general del micro\n\n1. Este archivo tiene **handlers por tipo de mensaje de status / edge** (no por modelo de dispositivo). Todos **parsean JSON**, hacen 1–2 comprobaciones y delegan en lógica interna:\n    \n    - `handleMessageDevice(...)` → actualiza `lastStatus.lastMsgTimestamp` a partir de `message.timestamp` (segundos Unix) y su versión GMT según timezone del device.\n    - `handleStatusInput(...)` → procesa el status “normal”: descarta mensajes viejos, actualiza `lastStatus.values/virtuals/timestamp`, pone `status=online` y publica `status.updated.<model>` + `status.notification.realtime`.\n    - `handleEdgeStatusMessage(...)` → procesa status de edge con `connectedDevices` y sincroniza conexiones/dispositivos dependientes.\n        \n2. **Helpers internos de negocio** (privados) que hacen el trabajo real sobre el “estado vivo” del dispositivo (cloud):\n    \n    - `_updateAlarmCount(device)` → recalcula `alarmCount` y `noAckAlarmCount` desde `lastStatus.alarms` y lo persiste en Mongo.\n    - `_checkDeviceNeedCalcVirtuals(device, message)` → calcula virtuals “healthy_*” (solo si `application === \"healthy-clima\"`) usando calendario laboral + setpoints/histeresis + valores del status.\n    - `_checkDeviceHomologateSync(device)` → para ciertas `commercialVersion` sincroniza `conf` desde SR (`SRConnector`) y actualiza el device en Mongo.\n    - `_updateConnectedDevices(message)` → orquesta la actualización de dispositivos conectados a un edge (crea tareas y ejecuta en serie).\n    - `_updateDeviceByEdge(connDev, edgeId)` → actualiza cada dispositivo “slave” (connectedTo/network/connectivity), publica `network.notification.realtime` y puede emitir `device.online`.\n    - `_updateEdgeConnections(connectedDevices, device)` → guarda la lista `connectedDevices` en el edge y publica realtime.\n    - `_removeOrphanConnectedTo(deviceEdge, connectedDevices)` → marca como error y desconecta los devices que ya no están en la lista (limpieza).\n        \n3. **Funciones de soporte / control de flujo** (protegen el micro y ordenan la ejecución):\n    \n    - Bloques `try { JSON.parse(msg) } catch { ... }` → descartan mensajes inválidos sin tumbar el micro.\n    - Validación temporal: descarta status antiguos (`moment(...).isAfter(...)`) para no pisar estados nuevos.\n    - Acceso a BD centralizado vía `getModel(\"device\")`, `getModel(\"deviceWorkTimetable\")` (modelo Mongoose).\n    - `serial(tasks)` → ejecuta updates de connectedDevices en serie para evitar carreras/orden incorrecto.\n    - Uso de `DateHelper.parseDeviceUTCOffset(...)` → normaliza timestamps en función del timezone del dispositivo.","x":-1480,"y":-600,"width":786,"height":411}
	],
	"edges":[]
}