{
	"nodes":[
		{"id":"0eddf535eb748f96","type":"text","text":"\nEste microservicio se llama “backlog.mediator.12830”. Al crearse, prepara dos cosas principales: un componente para **validar lo que llega** y otro para **organizar/interpretar los valores**, y configura un logger para registrar lo que hace.\n\n```js\nclass BacklogMediator extends Microservice {\n  // Nombre lógico del servicio (se usa típicamente para logs, métricas, trazas, etc.)\n  private _serviceName: string = \"backlog.mediator.12830\";\n  // Validador de mensajes de entrada (normalmente: estructura, campos obligatorios, tipos, rangos…)\n  private inputValidator: InputValidator;\n  // Clasifica/ordena valores (p.ej. separar params vs commands, normalizar formatos, etc.)\n  private valuesClassifier: ValuesClassifier;\n  // Logger del servicio (para trazas con el nombre del micro)\n  protected logger: LoggerHelper;\n  constructor() {\n    // Llama al constructor de la clase base Microservice.\n    // Normalmente ahí se inicializa configuración, conexiones (AMQP/DB), carga de handlers, etc.\n    super(__dirname);\n    // Crea el clasificador de valores que usará este micro.\n    this.valuesClassifier = new ValuesClassifier();\n    // Crea logger etiquetado con el nombre del servicio.\n    this.logger = new LoggerHelper(this._serviceName);\n  }\n}\n\n```","x":-327,"y":-221,"width":727,"height":321},
		{"id":"8e15e458b4fc0ddd","type":"text","text":"\nEste microservicio se llama “backlog.mediator.12830”. Al crearse, prepara dos cosas principales: un componente para **validar lo que llega** y otro para **organizar/interpretar los valores**, y configura un logger para registrar lo que hace.\n\nCuando llega un mensaje, esta parte se asegura de tener listo el “validador”. Si es la primera vez, prepara acceso a la base de datos (dispositivos y definiciones) y crea el validador. Luego deja trazas en el log y prepara una variable para guardar el mensaje ya interpretado.\n\n```js\npublic async handleInput(msg: string): Promise<any> {\n  // Si aún no existe el validador de entrada, lo inicializa la primera vez que entra un mensaje.\n  if (this.inputValidator === undefined) {\n    // Log: avisa que se está inicializando el validador y muestra el mensaje recibido.\n    this.log(\n      LogLevels.INFO,\n      \"inputValidator undefined, initializing... \" + msg\n    );\n    // Obtiene el modelo de base de datos \"deviceDefinition\".\n    const deviceDefinitionModel: Model<DeviceDefinitionModel> =\n      this.getModel(\"deviceDefinition\");\n    // Obtiene el modelo de base de datos \"device\".\n    const deviceModel: Model<DeviceModel> = this.getModel(\"device\");\n    // Crea repositorios (capas de acceso a datos) para definición y dispositivo.\n    const deviceDefinitionRepo = new DeviceDefinitionRepository(\n      deviceDefinitionModel\n    );\n    const deviceRepo = new DeviceRepository(deviceModel);\n    // Crea el InputValidator usando los repositorios:\n    // a partir de aquí el micro podrá validar mensajes comparándolos\n    // contra datos reales del device y su definición.\n    this.inputValidator = new InputValidator(\n      deviceRepo,\n      deviceDefinitionRepo\n    );\n  }\n  // Logs \"separador\" para que en consola se vea claro cada mensaje procesado.\n  this.log(\n    LogLevels.INFO,\n    \"----------------  ------------------ ------------------\"\n  );\n  // Log del mensaje recibido (en bruto).\n  this.log(\n    LogLevels.INFO,\n    \"Received message :: \" + msg\n  );\n  // Aquí se va a guardar el mensaje ya convertido a objeto (parseado).\n  let parsedMsg: APIOutgoingMessage;\n}\n\n```","x":-327,"y":240,"width":727,"height":321},
		{"id":"61e8d54e006e2102","type":"file","file":"AKO/AKO44/Docs/attachments/Pasted image 20260220111926.png","x":-960,"y":-123,"width":280,"height":684},
		{"id":"e0481a2abd8beb39","type":"file","file":"AKO/AKO44/Docs/attachments/Pasted image 20260220112342.png","x":-800,"y":680,"width":400,"height":138},
		{"id":"d7a3c8678d6d89ce","type":"text","text":">[!warning] _inputValidator_\n>[[AKO 44  - Driver Translator Perte - InputValidator workFlow.canvas]]","x":720,"y":338,"width":567,"height":126},
		{"id":"be516e0481dd8368","type":"text","text":"Si el mensaje no tiene la forma correcta, lo marca como error y no sigue.\n\n```js\n// Si el mensaje ya parseado NO cumple el formato esperado, se registra error y se ignora.\nif (!this.isValidAPIOutgoingMessage(parsedMsg)) {\n  this.log(\n    LogLevels.ERROR,\n    \"WRONG ApiOutgoingMessage structure :: \" + msg\n  );\n  return Promise.resolve();\n}\n```","x":-327,"y":680,"width":727,"height":321},
		{"id":"eb888d67c2d16b1e","type":"text","text":"JSON.parse\n- `JSON.parse(text: string)` convierte un texto JSON en un objeto.\n- Si el texto no es JSON válido, **lanza un error** (por eso el `try/catch`).","x":635,"y":628,"width":565,"height":112},
		{"id":"42df029c001191d3","type":"text","text":"Comprueba que el mensaje tenga los campos necesarios y en el formato correcto (serie, modelo, fecha, usuario, comentario y configuración).\n\n```js\nprivate isValidAPIOutgoingMessage(\n  msg: APIOutgoingMessage\n): msg is APIOutgoingMessage {\n  // Comprueba que existan los campos y que tengan el tipo correcto.\n  // Si todo cuadra, devuelve true; si algo falla, false.\n  return (\n    typeof msg.sn === \"string\" &&                     // número de serie\n    typeof msg.model === \"string\" &&                  // modelo\n    typeof msg.ts === \"number\" &&                     // marca de tiempo (número)\n    !isNaN(new Date(msg.ts).getTime()) &&             // que se pueda convertir a fecha válida\n    typeof msg.user === \"string\" &&                   // usuario\n    (msg.comment === null || typeof msg.comment === \"string\") && // comentario: null o texto\n    typeof msg.conf === \"object\"                      // configuración: objeto (clave/valor)\n  );\n}\n```","x":635,"y":1020,"width":727,"height":321},
		{"id":"aeaa94039b11e776","type":"text","text":"Se revisa el mensaje para asegurarse de que “tiene sentido” y que se puede procesar. La función espera el resultado de esa revisión antes de continuar.\n\n```js\n// Llama al validador para comprobar el mensaje ya parseado (y con estructura correcta).\n// \"await\" significa que espera a que termine la validación antes de seguir.\n// El resultado suele incluir si es válido y, a veces, datos adicionales o un motivo de error.\nconst validationResult = await this.inputValidator.validateMessage(\n  parsedMsg as APIOutgoingMessage\n);\n```","x":-327,"y":1140,"width":727,"height":280},
		{"id":"56a4cfc9004ee9d4","type":"text","text":">[!warning] _inputValidator\n>[[AKO 44  - Driver Translator Perte - InputValidator workFlow.canvas]]","x":720,"y":1540,"width":727,"height":140},
		{"id":"96a145cd00ea1936","type":"text","text":"Si el mensaje no pasa la revisión, se descarta. Si la pasa, se separa la información en dos partes: una para dejar registro (auditoría) y otra con la configuración que realmente se va a aplicar/enviar, y se muestra un resumen por logs.\n\n```js\n// Si el validador dice que NO es válido, se avisa por log y se ignora el mensaje.\nif (!validationResult.isValid) {\n  this.log(\n    LogLevels.WARN,\n    \"WRONG Message ::\" + msg\n  );\n  return Promise.resolve();\n}\n// Si llega aquí, el mensaje pasó la validación.\nthis.log(\n  LogLevels.INFO,\n  \"VALID Message ::\" + msg\n);\n// Clasifica/ordena los valores del mensaje usando:\n// - el mensaje parseado\n// - el dispositivo encontrado en la validación\n// - la definición del dispositivo (para saber qué es cada parámetro)\nconst classifyResult = this.valuesClassifier.classifyValues(\n  parsedMsg,\n  validationResult.device,\n  validationResult.DeviceDefinition\n);\n\n// Log de depuración: enseña un resumen de lo clasificado:\n// - a: parte \"audit\" (para auditoría)\n// - b: parte \"config\" (lo que irá al backlog/configuración)\nthis.log(\n  LogLevels.INFO,\n  \"classifyResult\" +\n    JSON.stringify({\n      a: classifyResult.auditMessage.audit,\n      b: classifyResult.backlogMessage.config,\n    })\n);\n```","x":-327,"y":1560,"width":727,"height":280},
		{"id":"4784baa38f2f929a","type":"text","text":"Esta función toma el mensaje recibido y lo divide en dos cosas:\n1. un registro de “lo que se pidió cambiar” (para dejar constancia), y\n2. la lista de cambios que de verdad se aplicarán al dispositivo.  \n    Además devuelve el propio dispositivo para continuar el proceso.\n\n```js\npublic classifyValues(\n  msg: APIOutgoingMessage,\n  device: Device,\n  deviceDefinition: DeviceDefinition\n): ClassifierResult {\n  // Revisa los valores que vienen en el mensaje y los separa en dos grupos:\n  // - cloudChanges: cambios “relevantes para auditoría / cloud”\n  // - deviceChanges: cambios “que realmente se aplican al dispositivo”\n  const { cloudChanges, deviceChanges } = this.checkCorrectValues(\n    msg,\n    device,\n    deviceDefinition\n  );\n  // Devuelve un objeto con 3 partes:\n  // 1) auditMessage: lo que se guardará como registro/auditoría\n  // 2) backlogMessage: lo que se enviará/guardará para aplicar la config al device\n  // 3) device: el objeto device (tal cual) para seguir usándolo en el flujo\n  return {\n    // Mensaje para auditoría: quién, cuándo y qué se quiso cambiar (cloudChanges)\n    auditMessage: {\n      device: {\n        serialNumber: device.serialNumber,\n        _id: device._id,\n        deviceDefinition: device.deviceDefinition,\n      },\n      user: msg.user,\n      timestamp: msg.ts,\n      audit: cloudChanges,\n    },\n    // Mensaje para backlog: quién, cuándo y qué se aplicará al dispositivo (deviceChanges)\n    backlogMessage: {\n      device: {\n        serialNumber: device.serialNumber,\n        _id: device._id,\n        deviceDefinition: device.deviceDefinition,\n      },\n      // Si el mensaje trae user, lo usa; si no, cae al createdBy del device.\n      user: msg.user ? msg.user : device.createdBy,\n      timestamp: msg.ts,\n      // Configuración que realmente se va a aplicar/enviar al dispositivo.\n      config: deviceChanges,\n    },\n    // Devuelve el device también para que el caller siga trabajando con él.\n    device: device,\n  };\n}\n```","x":700,"y":1880,"width":727,"height":280},
		{"id":"b08561d48e5f81e8","type":"file","file":"AKO/AKO44/Docs/attachments/Pasted image 20260220114948.png","x":1720,"y":1410,"width":267,"height":400},
		{"id":"79484baedfefd292","type":"text","text":"Recorre los parámetros que llegan en el mensaje y, para cada uno:\n- comprueba que exista en la definición del dispositivo,\n- convierte a número si hace falta,\n- si el valor **realmente cambia** y está dentro de lo permitido, lo guarda como “cambio pendiente”,\n- separándolo en dos listas:\n    - **deviceChanges** (lo que se aplicará al dispositivo),\n    - **cloudChanges** (lo que se guarda como cambio de cloud / auditoría).  \n        Si el valor es igual o no es válido, lo ignora.\n\n```js\nprivate checkCorrectValues(\n  msg: APIOutgoingMessage,\n  device: Device,\n  deviceDefinition: DeviceDefinition\n): { cloudChanges: Change[]; deviceChanges: Change[] } {\n  // Cambios que se registrarán como “cambios de cloud” (auditoría / pendientes en cloud)\n  const cloudChanges: Change[] = [];\n  // Cambios que se enviarán/aplicarán al dispositivo (backlog)\n  const deviceChanges: Change[] = [];\n  try {\n    // Recorre cada par (clave, valor) que viene en msg.conf\n    for (const [key, value] of Object.entries(msg.conf)) {\n      // Busca en la definición del dispositivo el parámetro cuya ref coincide con la clave enviada\n      const deviceConfItem: ConfItem = deviceDefinition.conf.find(\n        (property) => property.ref === key\n      );\n      try {\n        // Si el tipo de valor es numérico, fuerza la conversión a Number\n        // para poder comparar correctamente (evita comparar \"2\" vs 2).\n        if (\n          deviceConfItem.valueType === \"integer\" ||\n          deviceConfItem.valueType === \"float\"\n        ) {\n          this.logger.info(\n            `Conf valueType is a number: ${key} = ${value}, converting value to number for comparison`\n          );\n          msg.conf[key as string] = Number(msg.conf[key as string]);\n        }\n        // Si:\n        // - existe el parámetro en la definición (deviceConfItem)\n        // - el mensaje trae un valor para esa clave\n        // - y el valor nuevo es distinto del valor actual en device.conf\n        // entonces hay un cambio real que procesar.\n        if (\n          deviceConfItem &&\n          msg.conf[key as string] !== undefined &&\n          device.conf[key as string] !== msg.conf[key as string]\n        ) {\n          // Comprueba si el valor está dentro del rango permitido\n          // (o cumple reglas específicas como el “intervalo”).\n          if (this.checkIntervalValid(device, deviceConfItem, value)) {\n            // Valor que finalmente se guardará como “nuevo”\n            let finalValue = msg.conf[key as string];\n\n            // Si no es array y el tipo es numérico, vuelve a asegurar que sea Number.\n            if (\n              !Array.isArray(finalValue) &&\n              (deviceConfItem.valueType === \"integer\" ||\n                deviceConfItem.valueType === \"float\")\n            ) {\n              finalValue = Number(finalValue);\n            }\n            // Si el parámetro es de origen \"device\", el cambio va a deviceChanges (backlog)\n            if (deviceConfItem.origin === \"device\") {\n              deviceChanges.push({\n                code: deviceConfItem.code,                        // código interno\n                ref: deviceConfItem.ref,                          // ref cloud\n                user: msg.user ? msg.user : device.createdBy,     // quien lo pide\n                newValue: finalValue,                             // valor nuevo\n                oldValue:                                         // valor anterior (o null si no existía)\n                  device.conf[key as string] !== undefined\n                    ? device.conf[key as string]\n                    : null,\n                timestamp: msg.ts,                                // ojo: aquí usa msg.ts tal cual\n                origin: \"device\",\n                status: \"pending\",\n              });\n            // Si el parámetro es de origen \"cloud\", el cambio va a cloudChanges (auditoría)\n            } else if (deviceConfItem.origin === \"cloud\") {\n              cloudChanges.push({\n                code: deviceConfItem.code,\n                ref: deviceConfItem.ref,\n                user: msg.user ? msg.user : device.createdBy,\n                newValue: finalValue,\n                oldValue:\n                  device.conf[key as string] !== undefined\n                    ? device.conf[key as string]\n                    : null,\n                // Aquí convierte ts (segundos) a Date (milisegundos)\n                timestamp: new Date(msg.ts * 1000),\n                origin: \"cloud\",\n                status: \"pending\",\n              });\n            }\n          } else {\n            // Si el valor está fuera de rango, se ignora el cambio.\n            this.logger.warn(\n              `Value ${value} for key ${key}, for device ${device._id} - ${device.model} is not in the valid range. Skipping change.`\n            );\n          }\n        }\n        // Si el valor nuevo es igual al actual, lo registra y no hace nada.\n        if (\n          deviceConfItem &&\n          msg.conf[key as string] !== undefined &&\n          device.conf[key as string] === msg.conf[key as string]\n        ) {\n          this.logger.info(\n            `Value is the same for key: ${key}, value: ${value}. Skipping change.`\n          );\n        }\n      } catch (error) {\n        // Si hay error procesando una clave concreta, se loguea y se continúa con la siguiente.\n        this.logger.error(\n          \"Error processing key: \" +\n            key +\n            \" :: \" +\n            error +\n            \". Skipping change.\"\n        );\n      }\n    }\n  } catch (error) {\n    // Si falla el bucle completo por alguna razón, se loguea el error general.\n    this.logger.error(\"Failed to classify values :: \" + error);\n  }\n  // Devuelve ambos grupos de cambios\n  return {\n    cloudChanges: cloudChanges,\n    deviceChanges: deviceChanges,\n  };\n}\n```","x":1084,"y":2480,"width":727,"height":280},
		{"id":"b99d0f99de0aecd9","type":"file","file":"AKO/AKO44/Docs/attachments/Pasted image 20260220115059.png","x":1720,"y":1880,"width":267,"height":501},
		{"id":"fd7b6bed26384399","type":"text","text":"Esta función calcula un número “dependiendo del estado del dispositivo”. Si le pasas varias condiciones, prueba una por una y se queda con la primera que encaja. Si no encaja ninguna, usa un valor por defecto (si existe). Si no hay nada aplicable, devuelve `null`.\n\n```js\nprivate getConditionedValue(\n  device: Device,\n  conditionedValue: ConditionedValue\n): number | null {\n\n  // Caso 1: conditionedValue es un ARRAY de condiciones.\n  // Ej: [{ condition: {...}, result: X }, { condition: {...}, result: Y }]\n  if (Array.isArray(conditionedValue)) {\n    this.logger.info(\n      `Conditioned value is an array: ${JSON.stringify(conditionedValue)}`\n    );\n\n    // Recorre las condiciones en orden y devuelve el primer \"result\" cuya condición se cumpla.\n    for (const cond of conditionedValue) {\n      const result = this.evaluateCondition(device, {\n        condition: {\n          ref: cond.condition.ref,\n          operator: cond.condition.operator,\n          value: cond.condition.value,\n          result: cond.result,\n        },\n      });\n\n      // En cuanto una condición devuelve algo distinto de null, ese es el valor final.\n      if (result !== null) {\n        return result;\n      }\n    }\n\n    // Si ninguna condición aplica, no hay resultado condicionado.\n    return null;\n  }\n\n  // Caso 2: conditionedValue es un OBJETO (no array) y existe.\n  if (conditionedValue) {\n\n    // Si el objeto representa una \"condición operacional\" especial,\n    // delega en evaluateOperationalCondition (reglas especiales).\n    if (this.isOperationalCondition(conditionedValue)) {\n      this.logger.info(\n        `Conditioned value is an OPERATIONAL CONDITION: ${JSON.stringify(conditionedValue)}`\n      );\n      return this.evaluateOperationalCondition(\n        device,\n        conditionedValue as OperationalCondition\n      );\n    }\n\n    // Si no es operacional, se trata como una condición “normal” (SingleCondition).\n    this.logger.info(\n      `Conditioned value is an object: ${JSON.stringify(conditionedValue)}`\n    );\n\n    // Evalúa la condición y si da un valor, lo devuelve.\n    const result = this.evaluateCondition(\n      device,\n      conditionedValue as SingleCondition\n    );\n    if (result !== null) {\n      return result;\n    }\n  }\n\n  // Caso 3: si no se obtuvo valor por condiciones, devuelve el valor \"default\" si existe.\n  // Si no hay default, devuelve null.\n  return \"default\" in conditionedValue\n    ? conditionedValue.default ?? null\n    : null;\n}\n\n```","x":2460,"y":2340,"width":727,"height":280},
		{"id":"ee8c37aa046c393e","type":"text","text":"Esta función comprueba si el valor que quieres poner está **entre el mínimo y el máximo permitido**. Si el mínimo o máximo dependen de otras condiciones del dispositivo, primero los calcula. Si no puede calcular límites claros (o el valor no es numérico), deja pasar el cambio.\n\n```js\nprivate checkIntervalValid(\n  device: Device,\n  deviceDefinitionProperty: ConfItem,\n  value: number | string\n): boolean {\n  // Aquí se guardarán los límites “reales” ya calculados como números\n  let numericMin: number | null = null;\n  let numericMax: number | null = null;\n  // Saca de la definición el tipo y los límites min/max (que pueden ser números o “condicionados”)\n  const { valueType, minValue, maxValue } = deviceDefinitionProperty;\n  // --- MIN ---\n  if (typeof minValue !== \"number\") {\n    // Si minValue NO es número, significa que viene como objeto/condición\n    // (ej: depende de otro parámetro del device). Lo calcula con getConditionedValue.\n    this.logger.warn(`minValue is not a number: ${JSON.stringify(minValue)}`);\n    numericMin = this.getConditionedValue(device, minValue);\n  } else {\n    // Si ya es número, lo usa directamente\n    numericMin = Number(minValue);\n  }\n  // --- MAX ---\n  if (typeof maxValue !== \"number\") {\n    // Igual que min: si es condicionado, lo calcula.\n    this.logger.warn(`maxValue is not a number: ${JSON.stringify(maxValue)}`);\n    numericMax = this.getConditionedValue(device, maxValue);\n  } else {\n    // Si ya es número, lo usa tal cual\n    numericMax = Number(maxValue);\n  }\n  // Log para depuración: qué parámetro se está validando y qué límites le han quedado.\n  this.logger.info(\n    `Checking interval validity for ${deviceDefinitionProperty.ref} with value: ${value}, numericMin: ${numericMin}, numericMax: ${numericMax}`\n  );\n  // Solo valida rango si el tipo es numérico\n  const isNumericType = valueType === \"integer\" || valueType === \"float\";\n  // Solo valida si tiene ambos límites calculados (no null/undefined)\n  const hasValidRange =\n    numericMin !== null &&\n    numericMin !== undefined &&\n    numericMax !== null &&\n    numericMax !== undefined;\n  // Convierte el valor recibido a número (aunque venga como string)\n  const numericValue = Number(value);\n  // Si es numérico y hay rango válido, comprueba que numericValue esté dentro de [min, max]\n  if (isNumericType && hasValidRange) {\n    return (\n      numericValue >= Number(numericMin) &&\n      numericValue <= Number(numericMax)\n    );\n  }\n  // Si NO es numérico, o no hay rango claro, “da por válido” (no bloquea).\n  return true;\n}\n```","x":1680,"y":3000,"width":727,"height":280},
		{"id":"8c679be1bd58cf33","type":"text","text":"Mira un valor del dispositivo y, según la regla (`equals` o `in`), decide si “encaja”. Si encaja devuelve un número; si no, devuelve `null`.\n```js\nprivate evaluateCondition(\n  device: Device,\n  condition: SingleCondition\n): number | null {\n  // Si la referencia (ref) de la condición NO existe en device.conf,\n  // no se puede evaluar -> devuelve null.\n  if (!Object.keys(device.conf).includes(condition.condition[\"ref\"])) {\n    this.logger.warn(\n      `Condition reference not found in device configuration: ${\n        condition.condition[\"ref\"]\n      } :: ${JSON.stringify(device.conf)}`\n    );\n    return null;\n  }\n  // Obtiene el valor actual del dispositivo para esa ref.\n  const deviceValue = device.conf[condition.condition[\"ref\"]];\n  // Evalúa según el operador definido en la condición.\n  switch (condition.condition.operator) {\n    // Operador \"equals\": si el valor del device es igual al esperado,\n    // devuelve el \"result\" asociado a la condición.\n    case \"equals\":\n      if (condition.condition.value === deviceValue) {\n        return condition.condition.result;\n      }\n      break;\n    // Operador \"in\": si el valor del device está dentro de una lista de valores,\n    // devuelve el result.\n    case \"in\":\n      if (\n        Array.isArray(condition.condition.value) &&\n        condition.condition.value.includes(\n          device.conf[condition.condition.ref]\n        )\n      ) {\n        return condition.condition.result;\n      }\n      break;\n    // Si llega un operador que no soporta, lo avisa y no aplica condición.\n    default:\n      this.logger.warn(`Unsupported operator: ${condition.condition.operator}`);\n      break;\n  }\n  // Si no se cumple la condición, devuelve null.\n  return null;\n}\n\n```","x":3580,"y":1900,"width":727,"height":280},
		{"id":"3c3d7fb67f42051d","type":"text","text":"Mira un valor del dispositivo y, según la regla (`equals` o `in`), decide si “encaja”. Si encaja devuelve un número; si no, devuelve `null`.\n\n```js\nprivate isOperationalCondition(\n  condition: ConditionedValue\n): condition is OperationalCondition {\n  // Intenta identificar si \"condition\" es del tipo “operacional”\n  // (una condición que no compara, sino que calcula algo con varios refs).\n  return (\n    !Array.isArray(condition) &&\n    typeof Array.isArray((condition as OperationalCondition).ref) &&\n    typeof (condition as OperationalCondition).operation === \"string\"\n  );\n}\n```","x":3580,"y":2340,"width":727,"height":280},
		{"id":"17b5ddc258024072","type":"text","text":"Recoge varios valores numéricos del dispositivo (o números fijos) y luego hace una operación (sumar o restar). Devuelve el resultado o `null` si no puede.\n\n```js\nprivate evaluateOperationalCondition(\n  device: Device,\n  condition: OperationalCondition\n): number | null {\n  // Aquí acumula números para luego aplicar una operación (+ o -).\n  const values: Array<number> = [];\n  // Recorre cada \"ref\" definido en la condición operacional.\n  for (const ref of condition.ref) {\n    // Si el \"ref\" ya es un número literal, lo mete directamente.\n    if (typeof ref === \"number\") {\n      values.push(ref);\n      continue;\n    }\n    // Si es string/otro, lo trata como clave y busca en device.conf.\n    const refKey = ref.toString();\n    // Si no existe, avisa y lo salta.\n    if (!Object.keys(device.conf).includes(refKey)) {\n      this.logger.warn(\n        `Operational condition reference not found in device configuration: ${ref} :: ${JSON.stringify(device.conf)}`\n      );\n      continue;\n    }\n    // Lee el valor actual del device para ese ref.\n    const value = device.conf[ref];\n    // Solo acepta números. Si no es número, lo salta.\n    if (typeof value === \"number\") {\n      values.push(value);\n    } else {\n      this.logger.warn(\n        `Value for ref ${ref} is not a number and will be skipped: ${JSON.stringify(value)}`\n      );\n      continue;\n    }\n  }\n  this.logger.info(\n    `Collected values for operational condition: ${JSON.stringify(values)}`\n  );\n  // Aplica la operación indicada:\n  switch (condition.operation) {\n    // Suma todos los valores\n    case \"+\":\n      return values.reduce((acc, curr) => acc + curr, 0);\n    // Resta en cadena: v0 - v1 - v2 ...\n    case \"-\":\n      return values.reduce((acc, curr) => acc - curr);\n    // Operación no soportada\n    default:\n      this.logger.warn(`Unsupported operation: ${condition.operation}`);\n      return null;\n  }\n}\n\n```","x":3580,"y":2780,"width":727,"height":280},
		{"id":"90a4448296beade2","type":"text","text":"Después de clasificar, si hay cambios “de auditoría” manda un mensaje de auditoría. Y si hay cambios “para aplicar al dispositivo”, manda otro mensaje para crear un nuevo “backlog” de configuración. Si alguna lista viene vacía, no envía nada y solo lo deja reflejado en logs.\n\n```js\n// Si hay cambios de auditoría (lista audit no vacía), publica un evento \"audit.12830.input\".\n// Si no hay nada que auditar, solo lo escribe en el log.\nclassifyResult.auditMessage.audit.length > 0\n  ? this.sendEvent(\"audit.12830.input\", classifyResult.auditMessage)\n  : this.log(\n      LogLevels.INFO,\n      \"No audit message to send\"\n    );\n// Si hay cambios de configuración para el dispositivo (lista config no vacía),\n// publica un evento \"backlog.12830.new.conf\".\n// Si no hay cambios reales, solo lo escribe en el log.\nclassifyResult.backlogMessage.config.length > 0\n  ? this.sendEvent(\"backlog.12830.new.conf\", classifyResult.backlogMessage)\n  : this.log(\n      LogLevels.INFO,\n      \"No backlog message to send\"\n    );\n// Termina el procesamiento del mensaje.\nreturn Promise.resolve();\n```","x":-327,"y":2080,"width":727,"height":280}
	],
	"edges":[
		{"id":"5aeec5f56b9f8d5a","fromNode":"0eddf535eb748f96","fromSide":"bottom","toNode":"8e15e458b4fc0ddd","toSide":"top","label":"handleInput"},
		{"id":"a7f2832ad3e2b9e1","fromNode":"8e15e458b4fc0ddd","fromSide":"left","toNode":"61e8d54e006e2102","toSide":"right","label":"deviceDefinitionmodel"},
		{"id":"c919fde6900bdfe2","fromNode":"8e15e458b4fc0ddd","fromSide":"right","toNode":"d7a3c8678d6d89ce","toSide":"left","label":"InputValidator"},
		{"id":"de8b98ec676ee0db","fromNode":"8e15e458b4fc0ddd","fromSide":"left","toNode":"e0481a2abd8beb39","toSide":"top","label":"APIOutgoingMessage"},
		{"id":"84586a0be042ff1c","fromNode":"8e15e458b4fc0ddd","fromSide":"bottom","toNode":"be516e0481dd8368","toSide":"top","label":"handleInput"},
		{"id":"732982d4739fb71e","fromNode":"be516e0481dd8368","fromSide":"right","toNode":"eb888d67c2d16b1e","toSide":"left"},
		{"id":"d080e882a2282227","fromNode":"be516e0481dd8368","fromSide":"right","toNode":"42df029c001191d3","toSide":"top","label":"isValidAPIOutgoingMessage"},
		{"id":"9e90bd13efdaaf8e","fromNode":"be516e0481dd8368","fromSide":"bottom","toNode":"aeaa94039b11e776","toSide":"top","label":"handleInput"},
		{"id":"8731c4f91c3b1e80","fromNode":"aeaa94039b11e776","fromSide":"right","toNode":"56a4cfc9004ee9d4","toSide":"left","label":"inputValidator.validateMessage"},
		{"id":"dcabf51f14c7e2aa","fromNode":"aeaa94039b11e776","fromSide":"left","toNode":"e0481a2abd8beb39","toSide":"bottom","label":"APIOutgoingMessage"},
		{"id":"4de30240d653c807","fromNode":"aeaa94039b11e776","fromSide":"bottom","toNode":"96a145cd00ea1936","toSide":"top","label":"handleInput"},
		{"id":"44f4420bef6ec6eb","fromNode":"96a145cd00ea1936","fromSide":"right","toNode":"4784baa38f2f929a","toSide":"left","label":"valuesClassifier.classifyValues"},
		{"id":"85d0d53a8551a48c","fromNode":"4784baa38f2f929a","fromSide":"right","toNode":"b08561d48e5f81e8","toSide":"left","label":"Device"},
		{"id":"255ad77922914e12","fromNode":"4784baa38f2f929a","fromSide":"right","toNode":"b99d0f99de0aecd9","toSide":"left","label":"DeviceDefinition"},
		{"id":"518a59be7585c413","fromNode":"4784baa38f2f929a","fromSide":"right","toNode":"79484baedfefd292","toSide":"top","label":"checkCorrectValues"},
		{"id":"e47408b93e0ef23d","fromNode":"ee8c37aa046c393e","fromSide":"right","toNode":"fd7b6bed26384399","toSide":"left","label":"getConditionedValue"},
		{"id":"18f8cc7a9a07070f","fromNode":"fd7b6bed26384399","fromSide":"right","toNode":"8c679be1bd58cf33","toSide":"left","label":"evaluateCondition"},
		{"id":"126bd619cffa5c3c","fromNode":"fd7b6bed26384399","fromSide":"right","toNode":"3c3d7fb67f42051d","toSide":"left","label":"isOperationalCondition"},
		{"id":"27f789442dcd7e4f","fromNode":"fd7b6bed26384399","fromSide":"right","toNode":"17b5ddc258024072","toSide":"left","label":"evaluateOperationalCondition"},
		{"id":"1cc96de4c6c03f6c","fromNode":"79484baedfefd292","fromSide":"right","toNode":"ee8c37aa046c393e","toSide":"top","label":"checkIntervalValid"},
		{"id":"7553a24bcb60bdb2","fromNode":"96a145cd00ea1936","fromSide":"bottom","toNode":"90a4448296beade2","toSide":"top","label":"handleInput"}
	]
}