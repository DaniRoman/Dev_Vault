{
	"nodes":[
		{"id":"f0354f76143842ed","type":"text","text":"Este constructor aplica inyección de dependencias: recibe como parametros repositorios necesarios para validar dispositivos y gestionar metadatos (firmware, ficheros, PLMN, IP). Además recibe el contexto del microservicio y el protocolo para poder trazar y publicar correctamente. Al final inicializa dos loggers: uno “raw” orientado a tráfico/mensajes y otro estándar para logs del módulo `Authentication`.\n\n```js\nexport class Authentication {\n  // Logger “raw”: suele usarse para trazar mensajes tal cual (payload/CRC/dirección),\n  // y también para reenviar a Rabbit (en tu código se usa sendTranslator).\n  protected rawlogger: RawLogger;\n  // Logger estándar con formato/niveles (info/debug/error) para trazas del servicio.\n  protected logger: LoggerHelper;\n  public constructor(\n    // Repositorio de dispositivos “registrados” (DB principal)\n    protected deviceRepo: IDeviceRepository,\n    // Repositorio de dispositivos “manufactured” (pre-registrados/fabricación)\n    protected manufacturedDeviceRepo: IManufacturedDeviceRepository,\n    // Repo de ficheros (posibles config/recursos relacionados con el device)\n    protected filesRepo: IFileRepository,\n    // Repo de firmware updates\n    protected firmwareUpdateRepo: IFirmwareUpdateRepository,\n    // Repo de firmware del módem (NB-IoT / conectividad)\n    protected modemFirmwareUpdateRepo: IModemFirmwareUpdateRepository,\n    // Repo de PLMN list (listas de redes móviles / configuración NB-IoT)\n    protected plmnListRepo: IPlmnListRepository,\n    // Referencia al microservicio (para publicar, loguear, contexto)\n    microservice: Microservice,\n    // Protocolo (coap/mqtt/etc.) para que RawLogger etiquete/gestione correctamente\n    protocol: Protocol,\n    // Repo de IPs (p.ej. whitelisting / última IP conocida / reglas por IP)\n    protected ipRepo: IIPRepository,\n  ) {\n    // Instancia RawLogger con el contexto del micro y el protocolo para trazar/reenviar mensajes.\n    this.rawlogger = new RawLogger(microservice, protocol);\n    // Logger “normal” para logs del componente Authentication.\n    this.logger = new LoggerHelper(\"Authentication\");\n  }\n}\n```","x":-280,"y":40,"width":722,"height":352},
		{"id":"e42961464fc8c161","type":"text","text":">[!info] Inyección de dependencias\n>\n\nLa **inyección de dependencias (DI)** es una forma de diseñar código donde una clase **no crea por sí misma** los objetos que necesita para funcionar, sino que **se los pasan desde fuera** (por constructor, por parámetros o por un contenedor).\nEn vez de esto (acopla fuerte):\n\n```js\nclass Authentication {\n  private deviceRepo = new DeviceRepository(); // lo crea aquí\n}\n```\n\nSe hace esto (DI por constructor):\n\n```js\nclass Authentication {\n  constructor(private deviceRepo: IDeviceRepository) {}\n}\n```\n\n**Qué ganas con DI:**\n\n- Menos acoplamiento: `Authentication` no depende de una implementación concreta, solo de la interfaz (`IDeviceRepository`).\n- Test fácil: puedes pasar un “mock/fake repo” en tests sin tocar Mongo.\n- Más flexible: cambias repositorios/adapters (Mongo/Redis) sin reescribir la clase.\n- Mejor mantenimiento: cada pieza tiene una responsabilidad clara (la clase usa dependencias, otra parte las construye).\n\nEn el código, `Authentication` recibe `deviceRepo`, `filesRepo`, `ipRepo`, etc. desde fuera, así que es DI “manual” (sin framework).","x":680,"y":40,"width":722,"height":352},
		{"id":"0c9a33b2441eed5e","type":"text","text":">[!warning] Clase Authentication\n\nLa clase `Authentication` es el punto de entrada que valida y prepara mensajes de dispositivos (CoAP/MQTT/…) antes de que entren al resto del sistema. Comprueba el dispositivo por `serialNumber`. Valida  integridad del mensaje con `CheckIntegrity` (verifica CRC y extrae el payload limpio). Si el dispositivo tiene licencia (o si es una acción de `link`), aplica lógica adicional con `MessageProcessor` (firmware, ficheros, PLMN, modem firmware, IP). En paralelo registra trazas crudas de entrada/salida con `RawLogger` para auditoría/diagnóstico. Cuando el mensaje entrante es `create` y hay licencia, publica el mensaje ya preparado hacia el translator en `driver.input.perte`. También puede construir mensajes de salida hacia el dispositivo generando `payload + CRC` en `createMessageToSend`.","x":-280,"y":-520,"width":722,"height":352},
		{"id":"72822057d7ab2a26","type":"text","text":"Este inicio de función toma un mensaje entrante del device y lo primero que hace es comprobar que el `serialNumber` corresponde a un dispositivo válido, devolviendo su información (y el estado de validación) para decidir si el mensaje se acepta o se rechaza.\n\n```js\npublic async checkMessageRecived(\n  message: MessageParseCl,\n): Promise<ClLibResponse> {\n\n  // Valida el dispositivo a partir del serialNumber del mensaje entrante.\n  // Esta validación normalmente comprueba:\n  // - si el dispositivo existe en la BD (o en manufactured)\n  // - si tiene licencia\n  // - y devuelve un objeto DeviceInformation con datos del device\n  const deviceInfo: ClLibResponse<DeviceInformation> =\n    await this._validateSerialNumber(message.serialNumber);\n  // (El resto de la función continuará usando deviceInfo.status/body para decidir\n  // si procesa el mensaje, verifica CRC, lo publica al translator, etc.)\n}\n```","x":-280,"y":500,"width":722,"height":352},
		{"id":"81653f08705a9b53","type":"file","file":"AKO/AKO44/attachments/Pasted image 20260217112922.png","x":841,"y":460,"width":400,"height":148},
		{"id":"9affc8036641df93","type":"text","text":"Esta función encapsula la validación del dispositivo: construye un `SerialNumberValidator` con los repositorios necesarios, valida el `serialNumber` contra las fuentes disponibles (device y manufactured) y devuelve el resultado con `status` e información del dispositivo para que el resto del flujo decida si procesa el mensaje.\n\n```js\nprotected async _validateSerialNumber(\n  serialNumber: number | bigint,\n): Promise<ClLibResponse<DeviceInformation>> {\n\n  // Crea un validador específico para serial numbers.\n  // Se le inyectan repositorios para poder buscar el dispositivo en:\n  // - deviceRepo (dispositivos ya dados de alta)\n  // - manufacturedDeviceRepo (dispositivos “fabricados” pero quizá aún no vinculados)\n  // - ipRepo (datos auxiliares por SN, por ejemplo IP asociada)\n  // y un logger para trazas.\n  const serialNumberValidator = new SerialNumberValidator(\n    this.deviceRepo,\n    this.manufacturedDeviceRepo,\n    this.ipRepo,\n    this.logger,\n  );\n\n  // Ejecuta la validación real del dispositivo.\n  // Devuelve un ClLibResponse<DeviceInformation> con status (success/error)\n  // y body con la info del dispositivo si existe/está permitido.\n  const validateDevice =\n    await serialNumberValidator.validateDevice(serialNumber);\n\n  // Log de depuración: muestra el body que devuelve el validador.\n  const deviceInfo = validateDevice.body;\n  this.logger.log(\"debug\", \"deviceInfo:::\" + JSON.stringify(deviceInfo));\n\n  // Log de depuración: muestra si la validación fue success/error.\n  this.logger.log(\n    \"debug\",\n    \" serialNumberValidator.validateDevice ????: \" + validateDevice.status,\n  );\n\n  // Devuelve el resultado completo (status + body).\n  return validateDevice;\n}\n```","x":-1380,"y":500,"width":722,"height":352},
		{"id":"e076c3392b126566","type":"text","text":"Si el dispositivo se valida correctamente, se registra el payload recibido y se pasa por `CheckIntegrity` para comprobar que el mensaje no está corrupto (p. ej. validando el CRC) y obtener el payload “limpio” antes de continuar con el resto del flujo.\n\n```js\nif (deviceInfo.status == \"success\") {\n  // Si el serialNumber es válido y se ha encontrado/aceptado el dispositivo,\n  // se continúa con el procesamiento del mensaje.\n  // Log de depuración: muestra el payload recibido (antes de comprobar CRC/integridad).\n  this.logger.log(\n    \"debug\",\n    \"message.payload ::: \" + JSON.stringify(message.payload),\n  );\n  try {\n    // Crea el componente encargado de validar integridad del mensaje (p.ej. CRC)\n    // y de “extraer” el payload real si viene empaquetado con CRC.\n    const checkIntegrity = new CheckIntegrity(this.logger);\n    // Ejecuta la comprobación de integridad usando:\n    // - deviceInfo.body: datos del dispositivo (p.ej. uuid/clave/metadata necesaria para CRC)\n    // - message.payload: el payload tal como llegó (normalmente Buffer o estructura cruda)\n    // Devuelve un ClLibResponse con status y body (payload limpio + crc calculado, etc.).\n    const integrity: ClLibResponse = checkIntegrity.checkIntegrity(\n      deviceInfo.body,\n      message.payload,\n    );\n```","x":-280,"y":960,"width":722,"height":352},
		{"id":"16fd86454e88b468","type":"text","text":"Esta función valida la integridad de un mensaje entrante: comprueba que el dispositivo tenga UUID, decodifica el payload para separar el contenido real del CRC, extrae el CRC recibido y lo compara con el CRC calculado usando UUID+mensaje (excepto para firmwares 6700/0 donde lo fuerza como válido). Devuelve el payload ya decodificado y el CRC asociado para que el resto del pipeline procese el mensaje.\n\n```js\npublic checkIntegrity(deviceInfo: DeviceInformation, payload: PayloadType): ClLibResponse {\n  // Log: muestra el payload crudo como hex (útil para depurar CRC / framing)\n  this.logger.log(\"debug\", \"payload from device:\" + payload.toString(\"hex\"));\n  // Log: muestra el UUID del dispositivo (se usa para calcular/sembrar el CRC)\n  this.logger.log(\"debug\", \"Checking CRC for device:\" + deviceInfo.uuid);\n  // Si no hay UUID no se puede validar integridad (porque el CRC depende del UUID)\n  if (!deviceInfo.uuid) {\n    this.logger.log(\"error\", \"UUID is missing in deviceInfo:\" + JSON.stringify(deviceInfo));\n    return {\n      status: \"error\",\n    };\n  }\n  // Si el payload no existe o es demasiado corto para contener CRC (mínimo 4 bytes),\n  // se considera inválido por longitud.\n  // OJO: aquí se loguea error, pero se devuelve status \"success\" con payload vacío.\n  // Eso implica: \"no hay nada que validar/procesar\" más que \"integridad ok\".\n  if (!payload || (payload instanceof Buffer && (payload as Buffer).length < 4)) {\n    const length = (payload as Buffer).length;\n    this.logger.log(\"error\", \"Invalid payload length:\" + length);\n    return {\n      status: \"success\",\n      body: {\n        payload: {},\n        crc: \"\"\n      }\n    };\n  }\n  // Convierte a Buffer para tratarlo como bytes (CoAP body)\n  const payloadBuffer = (payload as Buffer);\n  this.logger.log(\"debug\", \"Payload Buffer (hex):\" + payloadBuffer.toString(\"hex\"));\n  // Decodifica el payload: separa “messageBuffer” (bytes del mensaje sin CRC)\n  // y “decodePayload” (objeto ya decodificado, p.ej. CBOR → JSON)\n  const { messageBuffer, decodePayload } = this._decodePayload(payloadBuffer);\n  this.logger.log(\"debug\", \"Message Buffer (hex):\" + messageBuffer.toString(\"hex\"));\n  this.logger.log(\"debug\", \"Message Payload decoded:\" + JSON.stringify(decodePayload));\n  // Extrae el CRC recibido (normalmente los últimos 4 bytes del payload original)\n  const messageCrc = this._getMessageCrc(payloadBuffer);\n  this.logger.log(\"debug\", \"Received CRC (hex):\" + messageCrc);\n  // Valida CRC:\n  // - Si firmwareVersion es 6700 o 0, se “salta” la validación (se fuerza crcValid=true)\n  // - Si no, calcula CRC esperado a partir de UUID + messageBuffer y lo compara con messageCrc\n  const isValidCrc =\n    (deviceInfo.device.firmwareVersion === 6700 || deviceInfo.device.firmwareVersion === 0)\n      ? { crcValid: true, crcCalc: messageCrc }\n      : this._calculateCrc31ForPayload(deviceInfo.uuid, messageBuffer, messageCrc);\n  // Loguea si es válido o no\n  this.logger.log(isValidCrc.crcValid ? \"info\" : \"error\", \"Is CRC valid? \" + isValidCrc.crcValid);\n  // Devuelve el resultado con:\n  // - status: success/error (según validez CRC)\n  // - body.payload: el payload ya decodificado\n  // - body.crc: el CRC calculado/aceptado\n  return {\n    status: isValidCrc ? \"success\" : \"error\", // OJO: aquí parece bug: debería ser isValidCrc.crcValid\n    body: {\n      payload: decodePayload,\n      crc: isValidCrc.crcCalc\n    }\n  };\n}\n\n```","x":800,"y":960,"width":722,"height":352},
		{"id":"106d39d39dac929c","type":"text","text":"Separa el payload en “mensaje sin CRC” y lo decodifica (p. ej. CBOR). Devuelve el buffer limpio y el objeto resultante.\n\n```js\nprivate _decodePayload(payload: Buffer): { messageBuffer: Buffer; decodePayload: JSON } {\n  // Debug: intenta decodificar el payload completo y lo imprime por consola.\n  // OJO: si el payload completo incluye CRC al final, este decode puede fallar o dar basura.\n  console.log(decode(payload));\n  // Se queda con el mensaje “real” quitando los últimos 4 bytes (que son el CRC)\n  const messageBuffer = payload.slice(0, payload.length - 4);\n  // Decodifica el mensaje sin CRC (normalmente CBOR → objeto)\n  const decodePayload = decode(messageBuffer);\n  // Devuelve tanto el buffer sin CRC como el objeto ya decodificado\n  return { messageBuffer: messageBuffer, decodePayload };\n}\n\n```","x":2000,"y":560,"width":722,"height":352},
		{"id":"ae053ae7b918ba5c","type":"text","text":"Extrae los últimos 4 bytes del payload y los devuelve como CRC en hexadecimal.\n\n```js\n/**\n * Extracts the CRC from the last 4 bytes of the payload.\n * @param payload - Full payload buffer including CRC.\n * @returns A hexadecimal string representing the CRC.\n */\nprivate _getMessageCrc(payload: Buffer): string {\n  // Toma los últimos 4 bytes del payload (CRC32 = 32 bits = 4 bytes)\n  // y los convierte a string hexadecimal.\n  const messageCrc = payload.slice(payload.length - 4).toString(\"hex\");\n  return messageCrc;\n}\n\n```","x":2000,"y":960,"width":722,"height":352},
		{"id":"1ca52230c5975f92","type":"text","text":"Calcula el CRC esperado para `uuid + payload` y lo compara contra el CRC recibido; devuelve si es válido y el CRC calculado.\n\n```js\n/**\n * Calculates the CRC of the payload and compares it to the received CRC.\n * @param uuid - UUID of the device used as part of CRC calculation.\n * @param payload - The raw buffer excluding the CRC bytes.\n * @param crc - The received CRC string in hexadecimal.\n * @returns A CrcResult object with validation status and calculated CRC.\n */\nprivate _calculateCrc31ForPayload(uuid: string, payload: Buffer, crc: string): CrcResult {\n  // Llama a la función central que calcula el CRC usando uuid + payload\n  // y lo compara con el CRC recibido.\n  const isValid: CrcResult = CRC32.getCRC(uuid, payload, crc);\n  return isValid;\n}\n```","x":2000,"y":1360,"width":722,"height":352},
		{"id":"9662104aea605806","type":"text","text":"Esta clase enruta el procesamiento de un mensaje entrante según el tipo de acción (`retrieve` o `create`). Recibe repositorios para acceder a recursos del sistema (ficheros, firmware, PLMN, IP) y usa un logger para trazar. Su método `process` decide qué flujo ejecutar y delega en métodos específicos (`processRetrive` / `processCreate`).\n\n_entrutar_: Actúa como un **dispatcher/router interno**: mira un campo del mensaje (`input.requestAction`) y, según su valor, **redirecciona la ejecución** a la función adecuada.\n\n```js\nexport class MessageProcessor {\n  // Constructor con inyección de dependencias: repos necesarios para consultar datos\n  // (ficheros, updates de firmware, PLMN list, IPs) y un logger para trazas.\n  public constructor(\n    private filesRepo: IFileRepository,\n    private firmwareUpdateRepo: IFirmwareUpdateRepository,\n    private modemFirmwareUpdateRepo: IModemFirmwareUpdateRepository,\n    private plmnListRepo: IPlmnListRepository,\n    private ipRepo: IIPRepository,\n    private logger: LoggerHelper\n  ) {}\n  public process(input: MessageParseCl, deviceInfo: DeviceInformation) {\n    // Log: inicio del procesamiento del mensaje\n    this.logger.info(\"PROCESS MESSAGE \" + \" Start process\");\n\n    // En función de la acción solicitada por el mensaje, deriva a la rutina adecuada:\n    // - retrieve: el dispositivo pide información/config (lectura)\n    // - create: el dispositivo está enviando datos/eventos (escritura/ingesta)\n    if (input.requestAction == \"retrieve\") {\n      return this.processRetrive(input, deviceInfo);\n    } else if (input.requestAction === \"create\") {\n      return this.processCreate(input, deviceInfo);\n    } else {\n      // Si llega una acción no soportada, no hace nada (aquí parece pendiente devolver 405 o similar)\n      // this._sendResponseToClient(response, 405, { message: \"Method Not Allowed\" });\n    }\n  }\n}\n```","x":-1460,"y":1420,"width":722,"height":352},
		{"id":"557891f71319a464","type":"text","text":"Si el CRC/decodificación es correcta, se comprueba si el mensaje debe procesarse (por licencia o por ser un `link`). Si procede, se instancia `MessageProcessor`, se reemplaza el payload por el payload “limpio” y se ejecuta el procesamiento con contexto del dispositivo. Finalmente se registra el mensaje entrante con `RawLogger`, guardando también el CRC usado/validado.\n\n```js\nif (integrity.status == \"success\") {\n  // Si la integridad (CRC/decodificación) es correcta, se continúa.\n  this.logger.log(\n    \"debug\",\n    \" => deviceInfo.body::::\" + JSON.stringify(deviceInfo.body),\n  );\n  // Decide si se debe procesar el mensaje:\n  // - normalmente solo si el dispositivo tiene licencia\n  // - o si es un mensaje especial de enlace/vinculación (\"link\")\n  const shouldProcessMessage =\n    deviceInfo.body.license || message.retiveAction === \"link\";\n  if (shouldProcessMessage) {\n    // Crea el processor que aplica reglas/lógica adicional sobre el mensaje:\n    // puede tocar ficheros, firmware, plmnlist, ip, etc.\n    const messageProcessor = new MessageProcessor(\n      this.filesRepo,\n      this.firmwareUpdateRepo,\n      this.modemFirmwareUpdateRepo,\n      this.plmnListRepo,\n      this.ipRepo,\n      this.logger,\n    );\n    // Sustituye el payload original por el payload ya validado/decodificado\n    // que viene de CheckIntegrity (es decir: sin CRC y ya “limpio”).\n    message.payload = integrity.body.payload;\n    // Procesa el mensaje con contexto del dispositivo:\n    // aquí se normalizan datos, se generan respuestas, se aplican reglas de negocio.\n    const responseMessageProcessor = await messageProcessor.process(\n      message,\n      deviceInfo.body,\n    );\n    // Registra el mensaje entrante “raw” (auditoría/diagnóstico), incluyendo CRC.\n    this.rawlogger.send(\n      \"incoming\",\n      deviceInfo.body,\n      message.payload,\n      integrity.body.crc,\n    );\n```","x":-280,"y":1420,"width":722,"height":352},
		{"id":"32341eb021ce9e15","type":"text","text":"Si el dispositivo tiene licencia, entonces el sistema permite procesar el mensaje. Si la acción es `create`, el resultado se publica al translator por RabbitMQ (`driver.input.perte`) y se responde “success” sin datos. Si no es `create`, se responde “success” y opcionalmente se incluye un `body` con la respuesta generada por el `MessageProcessor` (típico en `retrieve`).\n\n```js\nif (deviceInfo.body.license) {\n  // Solo si el dispositivo tiene licencia se permite continuar con el flujo “normal”\n  // (es decir, que el sistema acepte/propague el mensaje).\n  if (message.requestAction == \"create\") {\n    // Para mensajes de entrada \"create\" (el dispositivo “envía datos”):\n    // se publica el mensaje ya procesado hacia RabbitMQ para que lo consuma el translator.\n    // \"driver.input.perte\" es el routing key/topic de entrada del translator.\n    this.rawlogger.sendTranslator(\n      \"driver.input.perte\",\n      responseMessageProcessor.body as ClOutgoingMessage,\n    );\n    // Como este flujo es “fire-and-forget” hacia Rabbit, solo se devuelve success sin body.\n    return {\n      status: \"success\",\n    };\n  } else {\n    // Para otras acciones (por ejemplo \"retrieve\"):\n    // se devuelve success y, si el processor generó un body, se incluye en la respuesta.\n    // El spread condicional evita añadir \"body\" si viene vacío/null.\n    return {\n      status: \"success\",\n      ...(responseMessageProcessor.body && {\n        body: responseMessageProcessor.body,\n      }),\n    };\n  }\n}\n\n```","x":-280,"y":1940,"width":722,"height":352},
		{"id":"a9afbe850032e3bc","type":"text","text":"Si el dispositivo no pasa la validación “normal”, se abre una única puerta: aceptar acciones de `link` para dispositivos que existen solo en “manufactured”. Incluso en ese caso se valida CRC/decodifica, se procesa con `MessageProcessor`, y se deja trazabilidad para el flujo de vinculación.\n\n```js\nelse {\n  // Aquí entra cuando la validación del serialNumber NO ha sido \"success\"\n  // (es decir: el dispositivo no se considera válido en la BD principal, o la validación falló).\n  const body = deviceInfo.body;\n  // Debug: imprime el body devuelto por el validador, si existe en manufactured, y el mensaje recibido.\n  console.log(\"body:::\", body, body?.existsInManufactured, message);\n\n  // Excepción: permitir mensajes de \"link\" aunque el dispositivo no esté en la BD principal,\n  // siempre que sí exista en la tabla/colección de \"manufactured\".\n  if (\n    body &&\n    body.existsInManufactured == true &&\n    message.retiveAction === \"link\"\n  ) {\n    // accept link from devices in manufactured only\n    // Aun siendo \"manufactured only\", se verifica integridad (CRC) y se decodifica el payload.\n    const checkIntegrity = new CheckIntegrity(this.logger);\n    const integrity: ClLibResponse = checkIntegrity.checkIntegrity(\n      deviceInfo.body,\n      message.payload,\n    );\n    this.logger.log(\n      \"info\",\n      \"accept link from devices in manufactured only\",\n    );\n    // Se procesa el mensaje con las mismas reglas/capas que un mensaje normal:\n    // puede implicar ficheros, firmware, plmnlist, ip, etc.\n    const messageProcessor = new MessageProcessor(\n      this.filesRepo,\n      this.firmwareUpdateRepo,\n      this.modemFirmwareUpdateRepo,\n      this.plmnListRepo,\n      this.ipRepo,\n      this.logger,\n    );\n    // Se sustituye el payload crudo por el payload limpio/decodificado.\n    message.payload = integrity.body.payload;\n    // Ejecuta el procesamiento (normalmente link = flujo de vinculación/alta)\n    const responseMessageProcessor = await messageProcessor.process(\n      message,\n      deviceInfo.body,\n    );\n    // (En el resto del código normalmente se loguea raw y se responde;\n    // en tu versión completa, este camino acaba devolviendo status \"error\".)\n  }\n}\n\n```","x":680,"y":1540,"width":722,"height":352},
		{"id":"86f8a31b7f679d3c","type":"text","text":"[[error en mis#^73a187]]","x":3220,"y":474,"width":250,"height":60}
	],
	"edges":[
		{"id":"e87a52839b626c5a","fromNode":"0c9a33b2441eed5e","fromSide":"bottom","toNode":"f0354f76143842ed","toSide":"top"},
		{"id":"2d7a100c9e3a77ec","fromNode":"f0354f76143842ed","fromSide":"top","toNode":"e42961464fc8c161","toSide":"top","label":"Info inyección dependencias"},
		{"id":"9f6f9613b502982d","fromNode":"72822057d7ab2a26","fromSide":"top","toNode":"81653f08705a9b53","toSide":"left","label":"MessageParseCl"},
		{"id":"14c91d6b6a48fd35","fromNode":"72822057d7ab2a26","fromSide":"left","toNode":"9affc8036641df93","toSide":"right","label":"_validateSerialNumber"},
		{"id":"ef3857ac6529cb23","fromNode":"f0354f76143842ed","fromSide":"bottom","toNode":"72822057d7ab2a26","toSide":"top"},
		{"id":"ef648376800b9310","fromNode":"72822057d7ab2a26","fromSide":"bottom","toNode":"e076c3392b126566","toSide":"top"},
		{"id":"745c5c366fe2eaa4","fromNode":"e076c3392b126566","fromSide":"right","toNode":"16fd86454e88b468","toSide":"left","label":"CheckIntegrity"},
		{"id":"f140fdb62a743d29","fromNode":"16fd86454e88b468","fromSide":"right","toNode":"106d39d39dac929c","toSide":"left","label":"_decodePayload"},
		{"id":"9df5b811be615f6e","fromNode":"16fd86454e88b468","fromSide":"right","toNode":"ae053ae7b918ba5c","toSide":"left","label":"_getMessageCrc"},
		{"id":"a1b238f0b60e0205","fromNode":"16fd86454e88b468","fromSide":"right","toNode":"1ca52230c5975f92","toSide":"left","label":"_calculateCrc31ForPayload"},
		{"id":"45e866449be6bf9b","fromNode":"e076c3392b126566","fromSide":"bottom","toNode":"557891f71319a464","toSide":"top"},
		{"id":"a3e399996a9ac7ab","fromNode":"557891f71319a464","fromSide":"left","toNode":"9662104aea605806","toSide":"right","label":"MessageProcessor"},
		{"id":"25ebca7d097655b2","fromNode":"557891f71319a464","fromSide":"bottom","toNode":"32341eb021ce9e15","toSide":"top"},
		{"id":"a49be5a0066aeeb1","fromNode":"557891f71319a464","fromSide":"right","toNode":"a9afbe850032e3bc","toSide":"left","label":"Else"},
		{"id":"08f9ed1e1620f7e0","fromNode":"106d39d39dac929c","fromSide":"right","toNode":"86f8a31b7f679d3c","toSide":"bottom","label":"Error"}
	]
}