{
	"nodes":[
		{"id":"2d66790d4a2012b5","type":"text","text":">[!success] Info general del modulo\n\n1. Este archivo tienen un `handler` para cada tipo de dispositivo, \n\t- `handleStatusConfInputAD20(...)`\n\t- `handleStatusConfInputAD20V3(...)`\nparsean el JSON de entrada, recorren `message.conf`, y según `conf.ref` llaman a lógica interna.\n\n2. Una serie de funciones internas de negocio (helpers privados tipo `_check...` [[TypeScript - Main Site#^36fb64]]), aplican reglas (“si cambia este parámetro, actualiza esto en BD”), normalmente tocando valores/flags del dispositivo en el cloud.\n3. Funciones de soporte  que preparan y protegen el flujo, mientras los helpers implementan la lógica del dominio.; se encargan de que el micro pueda procesar mensajes de forma segura y consistente (parseo, validación mínima, inicialización, logs, manejo de errores).\n\n\t- `_initializeVariables()`\n\t- `_intializeVariables()` → prepara repositorios, parsers y servicios antes de procesar mensajes.\n\t- `_parseMessage(msg)` o un bloque `try { JSON.parse(msg) } catch { ... }` → convierte el string JSON a objeto y evita que el micro se caiga si viene mal formado.","x":-580,"y":-520,"width":680,"height":360},
		{"id":"222f360ae939fa72","type":"text","text":">[!success] Info general del modulo\n\nEste archivo tienen un `handler` para cada tipo de dispositivo, \n- `handleStatusConfInputAD20(...)`\n- `handleStatusConfInputAD20V3(...)`","x":440,"y":-430,"width":620,"height":180},
		{"id":"34664565fd224813","type":"text","text":">[!success] Info general del modulo\n\nEste archivo tienen un `handler` para cada tipo de dispositivo, \n- `handleStatusConfInputAD20(...)`\n- `handleStatusConfInputAD20V3(...)`","x":440,"y":-160,"width":620,"height":180},
		{"id":"36199fb2b29ef75e","type":"text","text":">[!success] info de un hanlde\n\ncuando el handler llama a un helper que este tiene que hacer una comprobación en la base de datos como por ejemplo `handleStatusConfInputAD20 > _checkingEnableProbesAd20`...","x":440,"y":-700,"width":620,"height":180},
		{"id":"9cfb270bac18e411","x":440,"y":-980,"width":620,"height":200,"type":"text","text":">[!question]\n\nTodos los micros extienden de la clase Microservice con lo que heredan el context [[AKO 44 - Flujo Registrar el Context.canvas]] del cual consiguen toda la info del device y del usuario "},
		{"id":"e0fc7fd79bc8285e","type":"text","text":">[!warning]\n\n `getModel` (Model Registry / Service Locator)\n\n- Pides el modelo por nombre: `this.getModel(\"device\")`.\n- Trabajas **directo con Mongoose** (`find`, `updateOne`, etc.) desde cada helper.\n- Ventaja: simple y rápido, menos capas.\n- Inconveniente: acceso a BD queda repartido y se repite; más difícil de testear/mantener.\n    \n Repository\n\n- Creas una clase `DeviceRepository` con métodos tipo `getById`, `setMute`, `setEnabledProbes`.\n- Los helpers llaman al repo y **no tocan Mongoose** directamente.\n- Ventaja: BD centralizada, menos duplicación, más testable, cambios en un solo sitio.\n- Inconveniente: más estructura/archivos, coste inicial de definir métodos.","x":1240,"y":-700,"width":620,"height":300}
	],
	"edges":[
		{"id":"ff72108129e7372c","fromNode":"2d66790d4a2012b5","fromSide":"right","toNode":"36199fb2b29ef75e","toSide":"left","label":"handleStatusConf.."},
		{"id":"c093a6741165cdb9","fromNode":"2d66790d4a2012b5","fromSide":"right","toNode":"222f360ae939fa72","toSide":"left","label":"_helpers"},
		{"id":"b8c0e43b88b36c52","fromNode":"2d66790d4a2012b5","fromSide":"right","toNode":"34664565fd224813","toSide":"left","label":"_soporte"},
		{"id":"ac1098d8b7fa6395","fromNode":"9cfb270bac18e411","fromSide":"bottom","toNode":"36199fb2b29ef75e","toSide":"top"},
		{"id":"dbe4b12c8f674a57","fromNode":"36199fb2b29ef75e","fromSide":"right","toNode":"e0fc7fd79bc8285e","toSide":"left"}
	]
}