{
	"nodes":[
		{"id":"3f0abeebb83cbc8f","type":"text","text":">[!warning] Todavía no se que forma acepta el body...\n>Tendremos que entrar dentro de las funciones para averiguar la forma de este\n\n\n","x":-3374,"y":-870,"width":820,"height":140},
		{"id":"deb412500be66700","type":"text","text":"\n- Verifica permisos**: el usuario que hace la petición debe tener el derecho `device.sendconf`.\n- Luego **carga el dispositivo** por `id` (solo campos necesarios: estado, serial, modelo, definición de parámetros, etc.).\n- Comprueba que el dispositivo **no esté en estados bloqueados** (`registered`, `suspended`, `cancelled`); si lo está, corta el flujo con un **error 412**.\n- Del body extrae qué se quiere cambiar: si viene en `{ conf: ... }` usa esa parte; si no, usa el body entero como cambios. También extrae un comentario opcional.\n- Filtra/valida esos cambios contra la definición del dispositivo (solo deja pasar parámetros “permitidos” según su `deviceDefinition.conf`).\n- Si tras validar hay cambios reales, **publica un mensaje a RabbitMQ** (AMQP) para que otro microservicio (backlog/driver) se encargue de entregarlos al dispositivo.\n- Devuelve **204 (No Content)** aunque el “envío” real sea asíncrono (no espera a que el dispositivo lo reciba, solo a que se publique el mensaje).\n![[Pasted image 20260219132353.png]]\n\n","x":-2714,"y":-310,"width":820,"height":360},
		{"id":"d415a0a83e17a603","type":"text","text":"**ruta** para enviar cambios de configuración a un dispositivo (por id) y  la forma exacta del body y le pasamos el context para tener la info del usuario \n![[Pasted image 20260219091426.png]]\n\n","x":-2394,"y":-870,"width":820,"height":360},
		{"id":"471e15db2abbb8b1","type":"text","text":"Si el usuario no tiene el derecho `device,` `sendconf`, corta la ejecución.\nDespués, si tiene permiso, hace un `get(id)` del dispositivo trayendo un **subset** de campos clave (`status`, `serialNumber`, `model`, `connectedTo`, `deviceDefinition.conf`, `commercialVersion`) que son los que se necesitan para las validaciones posteriores y para el envío de configuración.\n\n```js \nreturn this._checkPrivilege(\"device\", \"sendconf\")\n  // 1) Antes de hacer nada, valida que el usuario tenga permiso:\n  //    - recurso: \"device\"\n  //    - acción: \"sendconf\"\n  //    Si no tiene permiso, esta Promise se rechaza (401/403 típicamente)\n  //    y NO se ejecuta el .then().\n  .then(() => {\n    // 2) Si pasa la comprobación de permisos, carga el dispositivo por id\n    //    pero trayendo SOLO algunos campos (select) para:\n    //    - evitar traer datos innecesarios (performance)\n    //    - reducir superficie de exposición de datos\n    //    - disponer de lo mínimo para validar estado/configuración después.\n    return this.get(id, {\n      select: \"status serialNumber model connectedTo deviceDefinition.conf commercialVersion\",\n    });\n  });\n```\n\n","x":-1444,"y":-310,"width":820,"height":360},
		{"id":"41f16870a3fe351e","type":"text","text":"Si la opción `noCheckPrivilege` está activa, **no valida nada** y deja pasar. Si no, **llama al contexto** (`context.hasRight`) para verificar si el usuario tiene permisos sobre `resource` y `actions`.\n```js\nprotected _checkPrivilege(resource?: string, actions?: string | Array<string>): Promise<any> {\n  // Si el controlador está configurado para NO comprobar privilegios,\n  // se permite la operación directamente.\n  if (this._controllerOptions.noCheckPrivilege === true) {\n    return Promise.resolve();\n  }\n  // Si no está desactivada la comprobación, delega la validación real\n  // en el contexto (normalmente el usuario/logged session).\n  return this.context.hasRight(resource, actions);\n}\nprotected _controllerOptions: any = {};\n\n```\n\n","x":-484,"y":-910,"width":820,"height":360},
		{"id":"3b07f34bafa0432e","type":"text","text":"Comprueba si una persona puede hacer una acción en el sistema.\n- Si no hay nadie identificado (no hay usuario), lo rechaza.\n- Si es administrador, lo deja pasar siempre.\n- Si no es administrador, mira una lista de permisos:\n    - Si encuentra permiso para ese tipo de cosa (recurso) y para esa acción, lo permite.\n    - Si no lo encuentra, lo bloquea diciendo que no está permitido.\n\n```js\nhasRight(resource?: string, actions?: string | Array<string>): Promise<any> {\n\n  // Si no hay usuario en sesión/autenticado, no se puede autorizar nada.\n  // Devuelve 401 (Unauthorized).\n  if (!this._user) {\n    return Promise.reject({\n      status: 401\n    });\n  }\n\n  // Si el usuario es admin o superadmin, bypass total:\n  // se autoriza cualquier recurso/acción.\n  if (this._user.isAdmin || this._user.isSuperadmin) {\n    return Promise.resolve();\n  }\n\n  // Normaliza actions a array para tratarlo de forma uniforme.\n  // Ej: \"sendconf\" -> [\"sendconf\"]\n  if (actions && !Array.isArray(actions)) {\n    actions = [actions];\n  }\n\n  // Si existe la lista de privilegios del usuario, se valida contra ella.\n  if (this._privileges) {\n\n    // Si no se especifica resource, no se puede filtrar por recurso;\n    // este código decide permitir (resolve) en ese caso.\n    if (!resource) {\n      return Promise.resolve();\n    }\n\n    let hasRight = false;\n\n    // Recorre privilegios y busca coincidencia de resource (case-insensitive).\n    // Usa .some() para poder cortar el recorrido cuando encuentra el recurso.\n    this._privileges.some((privilege: { resource: string, actions: Array<string> }) => {\n      if (privilege.resource.toUpperCase() === resource.toUpperCase()) {\n\n        // Si no se especifican actions (o está vacío), basta con tener el recurso:\n        // => permiso concedido.\n        if (!actions || actions.length === 0) {\n          hasRight = true;\n        }\n        else {\n          // Si se especifican actions, concede permiso si AL MENOS UNA\n          // de las actions pedidas está incluida en privilege.actions.\n\n```\n\n","x":486,"y":-1550,"width":820,"height":360},
		{"id":"62218a1826608354","type":"text","text":"Esta función busca un dispositivo por su ID:\n\n1. **Comprueba** que el usuario pueda verlo.\n2. **Prepara** qué datos quiere traer.\n3. **Lo obtiene**.\n4. **Limpia/ajusta** los nombres de usuario del que lo creó y del que lo modificó.\n5. **Completa** la información con datos adicionales (pendientes, campos extra y configuración avanzada).\n6. Devuelve el dispositivo ya **listo para usar**.\n```js\npublic get(id: string, selectParams: any): Promise<IControllerResponse> {\n  return this._checkPrivilege()\n    // 1) Comprueba permisos (sin especificar recurso/acción: depende de la lógica interna)\n    .then(() => {\n      // 2) Ajusta/añade opciones extra antes de hacer el get real (según selectParams e id)\n      return this._extraGetOptions(selectParams, id);\n    })\n    .then(() => {\n      // 3) Llama al get \"real\" del padre (super) para traer el dispositivo por id\n      return super.get(id, selectParams).then((res: any) => {\n        // 4) Si existe createdBy.username, lo \"normaliza\" (p.ej. limpia/convierte email externo)\n        if (res && res.createdBy && res.createdBy.username) {\n          res.createdBy.username = parseExternalUserEmail(\n            res.createdBy.username,\n          );\n        }\n        // 5) Igual para updatedBy.username\n        if (res && res.updatedBy && res.updatedBy.username) {\n          res.updatedBy.username = parseExternalUserEmail(\n            res.updatedBy.username,\n          );\n        }\n        // 6) Devuelve el resultado ya “limpio”\n        return Promise.resolve(res);\n      }); // by id\n    })\n    .then((device: DeviceModel) => {\n      // 7) Añade/ajusta información relacionada con \"pendientes\" (según selectParams)\n      return this._extraGetPendingResponse(selectParams, device);\n    })\n    .then((device: DeviceModel) => {\n      // 8) Aplica selects extra (campos/relaciones adicionales) al dispositivo\n      //    Nota: lo mete en array porque esta función parece trabajar con listas\n      return this._extraGetSelects(selectParams, [device]);\n    })\n    .then((device: any) => {\n      // 9) Añade/ajusta configuración avanzada usando el primer elemento del array\n      return this._extraGetAdvanceConf(selectParams, device[0]);\n    })\n    .then((response: any) => {\n      // 10) Devuelve solo el primer elemento (espera un array)\n      return Promise.resolve(response[0]);\n    });\n}\n```","x":-434,"y":-310,"width":820,"height":360},
		{"id":"971faf97ef1a42e2","type":"text","text":"Si el que llama pide datos extra en el `select`, esta función “completa” los dispositivos:\n- si pide **deviceDefinition.*** → mete dentro del dispositivo su definición completa;\n- si pide **data.indicators** → calcula/trae indicadores del dispositivo (24h/6h/7d/30d o por fechas).\n\n```js\nprivate _extraGetSelects(\n  selectParams: any,\n  devices: Array<DeviceModel>,\n): Promise<Array<DeviceModel>> {\n  return Promise.resolve()\n    .then(() => {\n      const tasks: Array<Promise<any>> = [];\n      // Si en el select se pide algo que empieza por \"deviceDefinition.\"\n      // significa que el caller quiere datos detallados de la definición del dispositivo.\n      if (selectParams.select && selectParams.select.indexOf(\"deviceDefinition.\") !== -1) {\n        // Para cada dispositivo, dispara una tarea que carga su definición\n        // y la incrusta dentro del propio device.\n        if (devices && devices.length) {\n          devices.forEach((dev: any) => {\n            tasks.push(this._getDeviceDefinition(dev, selectParams.select));\n          });\n        }\n        // Ejecuta todas las cargas en paralelo y devuelve el array de devices ya enriquecidos.\n        return Promise.all(tasks);\n      } else {\n        // Si no se pidió deviceDefinition.* no hace nada.\n        return Promise.resolve(devices);\n      }\n    })\n    .then((devs: Array<DeviceModel>) => {\n      const tasks: Array<any> = [];\n      // Si en el select se piden indicadores (data.indicators),\n      // entonces calcula/trae indicadores para cada device.\n      if (selectParams.select && selectParams.select.indexOf(\"data.indicators\") !== -1) {\n        // Permite acotar por fechas si vienen en la request\n        const dateFrom = selectParams.dateFrom ? selectParams.dateFrom : undefined;\n        const dateTo   = selectParams.dateTo   ? selectParams.dateTo   : undefined;\n        // Por defecto usa 24h;\n\n```","x":1086,"y":170,"width":820,"height":360},
		{"id":"f9759a7a93901db9","type":"text","text":"Si quien pide los datos es **superadmin** y ha pedido **configuración avanzada**, esta función transforma la configuración del dispositivo a una lista donde cada parámetro sale con su **nombre**, su **código interno** y su **valor**, y la devuelve junto con el **número de serie**. Si no, devuelve el dispositivo sin cambios.\n\n```js\nprivate _extraGetAdvanceConf(selectParams: any, device: any) {\n  // Solo entra aquí si:\n  // - existe contexto y usuario\n  // - el usuario es superadmin\n  // - en el select se pidió \"confAdvance\"\n  if (\n    this.context &&\n    this.context.user &&\n    this.context.user.isSuperadmin &&\n    selectParams.select &&\n    selectParams.select.indexOf(\"confAdvance\") !== -1\n  ) {\n    // (Esta variable 'response' se construye pero realmente NO se usa después;\n    //  probablemente quedó de una versión anterior.)\n    const response = [\n      { serialNumber: device.serialNumber, conf: device.conf },\n    ];\n    // Aquí se construirá una lista \"traducida\" de configuración.\n    const configuration = [];\n    // Recorre cada parámetro de la configuración del dispositivo (device.conf)\n    for (const conf in device.conf) {\n      // Busca en la definición (device.deviceDefinition.conf) el parámetro cuyo \"ref\"\n      // coincide con el nombre del parámetro en cloud (conf).\n      // De ahí obtiene el \"code\" (código numérico/interno).\n      const code = device.deviceDefinition.conf\n        .filter((ddc: { code: string; ref: string }) => ddc.ref === conf)\n        .map((ddc: { code: string; ref: string }) => ddc.code);\n      // Si encontró código, añade una entrada con:\n      // - cloud_code: nombre/ref usado en cloud\n      // - code: código interno del parámetro (el primero encontrado)\n      // - value: valor actual del parámetro en el dispositivo\n      if (code && code.length) {\n        configuration.push({\n          cloud_code: conf,\n          code: code[0],\n          value: device.conf[conf],\n        });\n      }\n    }\n    // Devuelve un array con un objeto que contiene:\n    // - serialNumber\n    // - conf: lista de parámetros con su ref cloud, código interno y valor\n    return Promise.resolve([\n      { serialNumber: device.serialNumber, conf: configuration },\n    ]);\n  } else {\n    // Si no se cumplen las condiciones (no superadmin o no se pidió confAdvance),\n    // devuelve el device tal cual (envuelto en array).\n    return Promise.resolve([device]);\n  }\n}\n\n\n```","x":1086,"y":610,"width":820,"height":360},
		{"id":"1c899aa1cdcd5676","type":"text","text":"Amplía el `select` cuando se piden cosas especiales (config avanzada, indicadores, definición, imagen), asegura que `filter` sea un objeto, aplica filtro por `group`, **restringe** que ciertos usuarios vean dispositivos en estado `registered`, y en listados (sin `id`) filtra para incluir o excluir dispositivos `edge`.\n\n```js\nprivate _extraGetOptions(options: any, id?: any): Promise<any> {\n  return new Promise((resolve, reject) => {\n    // Si en el \"select\" se ha pedido \"confAdvance\" y el usuario es superadmin,\n    // añade campos extra necesarios para devolver esa configuración avanzada.\n    if (\n      options.select &&\n      options.select.indexOf(\"confAdvance\") !== -1 &&\n      this.context.user.isSuperadmin\n    ) {\n      options.select = options.select\n        ? (options.select += \" conf deviceDefinition.conf serialNumber\")\n        : \"conf deviceDefinition.conf serialNumber\";\n    }\n    // Si se piden indicadores (data.indicators), añade campos base relacionados\n    // (referencia externa, modelo, estado, última comunicación, etc.) + indicators.\n    if (options.select && options.select.indexOf(\"data.indicators\") !== -1) {\n      options.select = options.select\n        ? (options.select +=\n            \" externalReference model status lastStatus createdAt application indicators\")\n        : \"externalReference model status lastStatus createdAt application indicators\";\n    }\n    // Si se pide deviceDefinition, asegura también datos comerciales y versiones asociadas.\n    if (options.select && options.select.indexOf(\"deviceDefinition\") !== -1) {\n      options.select = options.select\n        ? (options.select +=\n            \" commercialVersion commercialName paramsMapVersion workmode\")\n        : \"commercialVersion commercialName paramsMapVersion workmode\";\n    }\n    // Si se pide \"image\" pero no \"imageUrl\", añade imageUrl (y commercialVersion).\n    if (\n      options.select &&\n      options.select.indexOf(\"image\") !== -1 &&\n      options.select.indexOf(\"imageUrl\") === -1\n    ) {\n      options.select = options.select += \" imageUrl commercialVersion\";\n    }\n    // Normaliza el filtro: si viene como string, lo convierte a objeto;\n    // si no existe, crea un filtro vacío.\n    if (options.filter) {\n      options.filter =\n        typeof options.filter == \"string\"\n          ? JSON.parse(options.filter)\n          : options.filter;\n    } else {\n      options.filter = {};\n    }\n    // Si llega \"group\", se asegura de incluir el campo \"groups\" en el select\n    // y añade filtro para devolver solo dispositivos de ese grupo.\n    if (options.group) {\n      if (!options.select || options.select.indexOf(\"groups\") === -1) {\n        options.select = options.select ? (options.select += \" groups\") : \"groups\";\n      }\n      options.filter.groups = options.group;\n    }\n    // Restricción por permisos:\n    // Si NO es admin/superadmin y NO es sesión especial de admin-app,\n    // y además NO tiene el privilegio device:create,\n    // entonces se excluyen dispositivos con status \"registered\".\n    if (\n      !this.context.user.isAdmin &&\n      !this.context.user.isSuperadmin &&\n      !this.context.isAdminAppSession\n    ) {\n      const privilegesNeed = \"create\";\n      const privilegesActiveDevice = this.context.user.privileges.find(\n        (pri: any) =>\n          pri.resource === \"device\" &&\n          pri.actions.indexOf(privilegesNeed) != -1,\n      );\n      if (!privilegesActiveDevice && options.filter) {\n        // Si no había filtro por status, añade: status != registered\n        if (!options.filter[\"status\"]) {\n          options.filter = Object.assign(options.filter, {\n            status: { $ne: \"registered\" },\n          });\n        } else {\n          // Si ya había filtro por status, combina:\n          // (status original) AND (status != registered)\n          options.filter[\"$and\"] = [\n            { status: options.filter[\"status\"] },\n            { status: { $ne: \"registered\" } },\n          ];\n          delete options.filter[\"status\"];\n        }\n      }\n    }\n    // Si NO viene \"id\", normalmente significa que es una búsqueda/listado (no un get por id).\n    // En ese caso, y si NO es sesión admin-app:\n    // - si options.edge => filtra solo type = \"edge\"\n    // - si no => excluye los edge (type != \"edge\")\n    if (!id) {\n      if (!this.context.isAdminAppSession) {\n        if (options.edge) {\n          options.filter = options.filter\n            ? Object.assign(options.filter, { type: \"edge\" })\n            : { type: \"edge\" };\n        } else {\n          options.filter = options.filter\n            ? Object.assign(options.filter, { type: { $ne: \"edge\" } })\n            : { type: { $ne: \"edge\" } };\n        }\n      }\n    }\n    // Termina: no devuelve datos, solo deja \"options\" preparado/modificado.\n    return resolve();\n  });\n}\n\n```","x":1086,"y":-670,"width":820,"height":360},
		{"id":"233ba8a68224c62a","type":"text","text":"Si quien llama pide ver la **configuración pendiente**, esta función busca si hay alguna pendiente para ese dispositivo y, si la encuentra, la **añade** al resultado (junto con la fecha). Si no hay, pone la lista vacía. Si no se pidió, no hace nada.\n\n```js\nprivate _extraGetPendingResponse(selectParams: any, device: DeviceModel) {\n  // Solo hace algo si en el \"select\" se ha pedido explícitamente \"pendingconf\".\n  if (selectParams.select && selectParams.select.indexOf(\"pendingconf\") !== -1) {\n    // Prepara la búsqueda de una configuración pendiente asociada a este dispositivo:\n    // - status: \"pending\" (pendiente)\n    // - device: id del dispositivo\n    const options = {\n      status: \"pending\",\n      device: mongoose.Types.ObjectId(device._id),\n    };\n    // Busca en Backlog (cola/registro) si existe una config pendiente para ese device.\n    return Backlog.findOne(options).then((backlog: any) => {\n      if (backlog) {\n        // Si existe, la añade al objeto device:\n        // - pendingConf: la configuración pendiente\n        // - pendingConfDate: fecha de última actualización (updatedAtGMT)\n        device.pendingConf = backlog.config;\n        device.pendingConfDate = backlog.updatedAtGMT;\n        return Promise.resolve(device);\n      } else {\n        // Si no existe backlog pendiente, deja pendingConf como vacío.\n        device.pendingConf = [];\n        return Promise.resolve(device);\n      }\n    });\n  } else {\n    // Si no se pidió pendingconf en el select, no consulta nada y devuelve el device tal cual.\n    return Promise.resolve(device);\n  }\n}\n\n```","x":1086,"y":-250,"width":820,"height":360},
		{"id":"beb197aa1518f257","type":"text","text":"Busca la “ficha” del tipo de dispositivo y se la pega al dispositivo. Si hay varias versiones de esa ficha (por versión comercial), elige la que toca.\n\n```js\nprivate _getDeviceDefinition(\n  dev: DeviceModel,\n  selectOps: any,\n  values?: any,\n): any {\n  // Carga la definición del dispositivo desde BD usando el id que tiene el device.\n  return DeviceDefinition.findById(dev.deviceDefinition).then(\n    (def: DeviceDefinitionModel) => {\n      // Si la definición tiene \"commercialVersions\", usa una versión de definición\n      // ajustada a la versión comercial del dispositivo (y otros parámetros).\n      if (def && def.commercialVersions && def.commercialVersions.length) {\n        const commercialVersionDeviceDefinition =\n          def.getDefinitionByCommercialVersion(\n            dev.commercialVersion,     // versión comercial del device\n            dev.paramsMapVersion,      // versión de mapa de parámetros\n            selectOps,                 // qué campos se han pedido en select\n            dev.workmode,              // modo de trabajo\n            values,                    // valores opcionales\n          );\n        // Sustituye dev.deviceDefinition por la definición \"filtrada\" para ese device.\n        dev.deviceDefinition = commercialVersionDeviceDefinition;\n      } else {\n        // Si no hay versiones comerciales, mete la definición tal cual.\n        dev.deviceDefinition = def;\n      }\n      // Devuelve el device ya con la definición dentro.\n      return dev;\n    },\n  );\n}\n\n```","x":2426,"y":-70,"width":820,"height":360},
		{"id":"50273c3e98d9430d","type":"text","text":"1.   \nRellena el dispositivo con “estadísticas/indicadores” recientes. Si ya existen guardados, los reutiliza; si no, los calcula y los guarda para la próxima vez.\n2. Decide si la petición es por **rango predefinido** (6h/24h/7d/30d) o por **fechas concretas** (`dateFrom/dateTo`).\n3. Determina `companyId`:\n    - si es petición pública o contexto sistema → usa la empresa del device\n    - si no → usa la empresa del contexto (la del usuario)\n4. Si es por rango predefinido (y no hay dateFrom/dateTo), intenta primero **leer de caché** (colección `Indicator`):\n    - si hay indicador guardado con datos → lo usa y ya está\n    - si no hay → marca que **debería guardarlo en caché** después\n5. Si no hay datos aún (`!dev.indicators`), calcula indicadores según `dev.model`:\n    - AD1, AD2, AD3, AD12, AD20, AD20V3, etc. → llama a su `XMetrics.getIndicators(...)`\n    - En algunos modelos, si viene todo a null, decide **no guardar caché**\n    - Si modelo no soportado → `dev.indicators = {}`\n6. Si estaba marcado `requireSaveInCache`, guarda/actualiza la caché con `findOneAndUpdate(... upsert:true ...)`.    \n    - Si falla, lo loguea y aun así devuelve el device.","x":2406,"y":490,"width":820,"height":360},
		{"id":"1cc51f9e99976880","type":"text","text":">[!info] Concepto de código\n>**`indexOf(...)` devuelve `-1` cuando NO existe**.\n\n```js\n//Si existe\noptions.select.indexOf(\"confAdvance\") !== -1\n//No existe\noptions.select.indexOf(\"confAdvance\") === -1\n```","x":1406,"y":-1110,"width":579,"height":280},
		{"id":"bcfb9c0a21b52717","type":"text","text":"es el “molde” de datos de una definición de dispositivo: nombre, modelo, parámetros de configuración (`conf`), eventos, alarmas, entradas, comandos, etc., y además un método `getDefinitionByCommercialVersion(...)` para sacar la versión adecuada.\n\n```js\nprivate _getDeviceDefinition(\n  dev: DeviceModel,\n  selectOps: any,\n\n): any {\n  // Carga la definición del dispositivo desde BD usando el id que tiene el device.\n  return DeviceDefinition.findById(dev.deviceDefinition).then(\n    (def: DeviceDefinitionModel) => {\n      // Si la definición tiene \"commercialVersions\", usa una versión de definición\n      // ajustada a la versión comercial del dispositivo (y otros parámetros).\n      if (def && def.commercialVersions && def.commercialVersions.length) {\n        const commercialVersionDeviceDefinition =\n          def.getDefinitionByCommercialVersion(\n            dev.commercialVersion,     // versión comercial del device\n            dev.paramsMapVersion,      // versión de mapa de parámetros\n            selectOps,                 // qué campos se han pedido en select\n            dev.workmode,              // modo de trabajo\n            values,                    // valores opcionales\n          );\n        // Sustituye dev.deviceDefinition por la definición \"filtrada\" para ese device.\n        dev.deviceDefinition = commercialVersionDeviceDefinition;\n      } else {\n        // Si no hay versiones comerciales, mete la definición tal cual.\n        dev.deviceDefinition = def;\n      }\n      // Devuelve el device ya con la definición dentro.\n      return dev;\n    },\n  );\n}\n\n```","x":3686,"y":-70,"width":820,"height":360},
		{"id":"e82426482f152275","type":"text","text":"Primero se asegura de que el dispositivo **puede recibir cambios**. Luego saca los cambios que hay que enviar (y un comentario si existe), **filtra** esos cambios para quedarse solo con los parámetros válidos para ese modelo, y devuelve el dispositivo junto con la configuración ya “limpia”.\n```js \n.then((dev: DeviceModel) => {\n\n  // 1) Bloquea el proceso si el dispositivo está en un estado donde no admite cambios.\n  if ([\"registered\", \"suspended\", \"cancelled\"].indexOf(dev.status) > -1) {\n    return Promise.reject({\n      status: 412,\n      message:\n        \"Device in status '\" +\n        dev.status +\n        \"' can't receive parameter changes\",\n    });\n  }\n\n  // 2) Decide de dónde sacar los cambios de configuración:\n  // - Si deviceConfiguration tiene la propiedad \"conf\", usa esa parte (deviceConfiguration.conf)\n  // - Si no, asume que deviceConfiguration ya ES directamente la config.\n  configChanges =\n    deviceConfiguration && deviceConfiguration.conf\n      ? deviceConfiguration.conf\n      : deviceConfiguration;\n\n  // 3) Extrae el comentario (si viene), si no, lo deja a null.\n  commentChanges =\n    deviceConfiguration && deviceConfiguration.comment\n      ? deviceConfiguration.comment\n      : null;\n  // 4) Valida/filtra la configuración: se queda solo con parámetros permitidos para ese dispositivo.\n  // Después devuelve un objeto con:\n  // - device: el dispositivo\n  // - parameters: la configuración ya validada/filtrada\n  return this._validateConfiguration(dev, configChanges).then(\n    (validatedConfiguration: any) => {\n      return { device: dev, parameters: validatedConfiguration };\n    },\n  );\n})\n\n```\n\n","x":-1444,"y":230,"width":820,"height":360},
		{"id":"cbf81aa4619af938","type":"text","text":"Si hay cambios reales que enviar, los manda al dispositivo (junto con quién lo pidió y un comentario). Luego responde con “todo OK” sin devolver datos.\n```js \n.then((data: { device: DeviceModel; parameters: any }) => {\n  // Si hay al menos un parámetro para enviar (no está vacío)...\n  if (Object.keys(data.parameters).length > 0) {\n    // ...envía la configuración al dispositivo a través del sistema de mensajería (AMQP),\n    // incluyendo:\n    // - el id del usuario que lo solicita\n    // - el dispositivo destino\n    // - los parámetros a aplicar\n    // - el comentario (si lo había)\n    SendAmqp.sendConfig(\n      this.context.user._id,\n      data.device,\n      data.parameters,\n      commentChanges,\n    );\n  }\n  // Devuelve 204: operación aceptada/sin contenido de respuesta.\n  // (Aunque no hubiera parámetros, responde igual.)\n  return Promise.resolve({\n    status: 204,\n  });\n});\n\n```\n\n","x":-1444,"y":770,"width":820,"height":360},
		{"id":"1feb39080ed25a61","type":"text","text":"Esta función **filtra** lo que te han pedido cambiar: se queda **solo** con los parámetros que realmente existen para ese tipo de dispositivo y que están marcados como “se pueden configurar”. Lo demás lo ignora y no lo envía.\n\n```js \nprivate _validateConfiguration(\n  device: DeviceModel,\n  parameters: any,\n): Promise<any> {\n  return new Promise((resolve, reject) => {\n    // Aquí se irán guardando SOLO los parámetros que sean válidos según la definición del dispositivo.\n    const validParameters: any = {};\n    // Recorre todas las claves de parámetros que te han pedido cambiar/enviar\n    Object.keys(parameters).forEach((paramKey) => {\n      // Recorre la lista de parámetros definidos para ese modelo de dispositivo (deviceDefinition.conf)\n      // y comprueba si existe uno cuyo \"ref\" coincide con la clave que nos han pasado\n      // y además NO está marcado como \"no es parámetro\" (isParam !== false).\n      (<DeviceDefinitionModel>device.deviceDefinition).conf.forEach((confParam: any) => {\n        if (confParam.ref === paramKey && confParam.isParam !== false) {\n          // Si coincide y es un parámetro permitido, lo añade al objeto final de parámetros válidos.\n          validParameters[paramKey] = parameters[paramKey];\n        }\n      });\n    });\n    // Devuelve únicamente los parámetros que han pasado la validación.\n    return resolve(validParameters);\n  });\n}\n```\n\n","x":-294,"y":230,"width":820,"height":360},
		{"id":"c14b0a8df714a1a0","type":"text","text":"Elige cómo mandar la configuración dependiendo del tipo de dispositivo (antiguo o nuevo).\n\n```js \npublic sendConfig(userId: string, device: DeviceModel, configuration: any, comment?: string): void {\n  // Decide qué “formato/canal” de envío usar según si el dispositivo es antiguo o no.\n  // - Si es antiguo => sendConfigLegacy(...)\n  // - Si no => sendConfig12830(...)\n  const newDevice = isOldDevice(device.model)\n    ? this.sendConfigLegacy(userId, device, configuration, comment)\n    : this.sendConfig12830(userId, device, configuration, comment);\n  // Nota: 'newDevice' no se usa; aquí sobra porque ambas funciones devuelven void.\n}\n```\n\n","x":-2634,"y":770,"width":820,"height":360},
		{"id":"c94507188c16856d","type":"text","text":"Prepara un mensaje con la configuración y lo manda a una “cola/canal” que depende del modelo del equipo (para equipos antiguos).\n\n```js \npublic sendConfigLegacy(userId: string, device: DeviceModel, configuration: any, comment?: string): void {\n  // Construye una “clave de destino” que depende del modelo del dispositivo.\n  const topicKey = \"backlog.input.\" + device.model;\n  // Construye el mensaje con datos básicos + configuración a aplicar.\n  const message = {\n    sn: device.serialNumber,          // número de serie\n    model: device.model,              // modelo\n    ts: new Date().getTime() / 1000,  // timestamp en segundos\n    user: userId,                     // quién lo solicita\n    comment: comment,                 // comentario opcional\n    conf: configuration               // configuración a enviar\n  };\n  // Solo envía si existe el canal AMQP abierto/configurado.\n  if (this._amqpChannel) {\n    // Log de depuración para ver exchange, routingKey y payload.\n    console.log(\n      \"info\",\n      \"PUBLISH SEND CONFIG ::  Exchange : \" +\n        this._exchange + this._environmentSuffix +\n        \" :: RoutingKey : \" + topicKey +\n        \" ::  Payload : \" + JSON.stringify(message)\n    );\n    // Publica el mensaje en el exchange con la routing key calculada.\n    this._amqpChannel.publish(\n      this._exchange + this._environmentSuffix, // exchange (con sufijo de entorno)\n      topicKey,                                 // routing key (depende del modelo)\n      Buffer.from(JSON.stringify(message)),      // payload JSON\n      { contentType: \"application/json\" }        // metadata\n    );\n  }\n}\n```\n\n","x":-3734,"y":350,"width":820,"height":360},
		{"id":"e2240b8b8fdbb02a","type":"text","text":"Hace lo mismo que la anterior (manda la configuración), pero lo envía siempre al mismo destino “estándar” (para equipos del flujo nuevo).\n\n```js \npublic sendConfig12830(userId: string, device: DeviceModel, configuration: any, comment?: string): void {\n  // Aquí el destino es fijo (no depende del modelo).\n  const topicKey = \"backlog.12830.input\";\n  // El contenido del mensaje es el mismo formato que en legacy.\n  const message = {\n    sn: device.serialNumber,\n    model: device.model,\n    ts: new Date().getTime() / 1000,\n    user: userId,\n    comment: comment,\n    conf: configuration\n  };\n  // Solo envía si existe el canal AMQP.\n  if (this._amqpChannel) {\n    console.log(\n      \"info\",\n      \"PUBLISH SEND CONFIG ::  Exchange : \" +\n        this._exchange + this._environmentSuffix +\n        \" :: RoutingKey : \" + topicKey +\n        \" ::  Payload : \" + JSON.stringify(message)\n    );\n    // Publica en exchange, con routingKey fija para este “nuevo” flujo.\n    this._amqpChannel.publish(\n      this._exchange + this._environmentSuffix,\n      topicKey,\n      Buffer.from(JSON.stringify(message)),\n      { contentType: \"application/json\" }\n    );\n  }\n}\n```\n\n","x":-3734,"y":1190,"width":820,"height":360},
		{"id":"aad56881377bdea8","type":"text","text":">[!info] Como saber que microservicio estara suscrito a esto??\n>[[Rabbit Main Page#^4fb97f]]","x":-4505,"y":742,"width":591,"height":88},
		{"id":"1a2a0fb59f7cc4d1","type":"text","text":">[!info] Enlace para Setear el flujo de Context\n[[AKO 44 - Flujo Registrar el Context.canvas]]","x":-2304,"y":-1120,"width":820,"height":123},
		{"id":"165ceebc50e70c0a","x":486,"y":-2000,"width":820,"height":301,"type":"text","text":">[!warning] En mi caso\nEl usuario que se crea un el token es superadmin y no es necesario buscar en ninguna lista de posibles acciones \n\n![[Pasted image 20260223125127.png]]"},
		{"id":"3e4f2957855a8de7","x":-360,"y":770,"width":1060,"height":390,"type":"text","text":">[!warning] Esta función chequea lo que mandas contra la **definición guardada** del dispositivo.\n\n\n>![[Pasted image 20260223131204.png]]\n\n![[Pasted image 20260223131220.png]]"}
	],
	"edges":[
		{"id":"8ed59e4c5a3c1ef1","fromNode":"d415a0a83e17a603","fromSide":"left","toNode":"3f0abeebb83cbc8f","toSide":"right","label":"req.body"},
		{"id":"edf727ce77626039","fromNode":"deb412500be66700","fromSide":"right","toNode":"471e15db2abbb8b1","toSide":"left","label":"sendConfiguration-then()"},
		{"id":"40404def6aa7b109","fromNode":"d415a0a83e17a603","fromSide":"bottom","toNode":"deb412500be66700","toSide":"top","label":"sendConfiguration"},
		{"id":"6870e8a372ca354f","fromNode":"471e15db2abbb8b1","fromSide":"right","toNode":"41f16870a3fe351e","toSide":"left","label":"_checkPrivilege"},
		{"id":"d2697b943a2ce8b5","fromNode":"471e15db2abbb8b1","fromSide":"right","toNode":"62218a1826608354","toSide":"left","label":"get"},
		{"id":"bdf3d117976ee946","fromNode":"471e15db2abbb8b1","fromSide":"bottom","toNode":"e82426482f152275","toSide":"top","label":"sendConfiguration-then()"},
		{"id":"3e42faba4a7e5d9f","fromNode":"41f16870a3fe351e","fromSide":"right","toNode":"3b07f34bafa0432e","toSide":"left","label":"hasRight()"},
		{"id":"94b85ced0b05f0f1","fromNode":"62218a1826608354","fromSide":"right","toNode":"1c899aa1cdcd5676","toSide":"left","label":"_extraGetOptions"},
		{"id":"c23165bd8cf53e53","fromNode":"62218a1826608354","fromSide":"right","toNode":"233ba8a68224c62a","toSide":"left","label":"_extraGetPendingResponse"},
		{"id":"821484dbf9573467","fromNode":"62218a1826608354","fromSide":"right","toNode":"971faf97ef1a42e2","toSide":"left","label":"_extraGetSelects"},
		{"id":"d594ee70e38d8e72","fromNode":"62218a1826608354","fromSide":"right","toNode":"f9759a7a93901db9","toSide":"left","label":"_extraGetAdvanceConf"},
		{"id":"865891a0de857d97","fromNode":"971faf97ef1a42e2","fromSide":"right","toNode":"beb197aa1518f257","toSide":"left","label":"_getDeviceDefinition"},
		{"id":"86c4f58c4588d82b","fromNode":"971faf97ef1a42e2","fromSide":"right","toNode":"50273c3e98d9430d","toSide":"left","label":"_getIndicators"},
		{"id":"4cd18b4e5d88804a","fromNode":"1c899aa1cdcd5676","fromSide":"top","toNode":"1cc51f9e99976880","toSide":"bottom","label":"codigo"},
		{"id":"4ab5aeef80d253e5","fromNode":"beb197aa1518f257","fromSide":"right","toNode":"bcfb9c0a21b52717","toSide":"left","label":"DeviceDefinitionModel"},
		{"id":"f18b927f2c76e310","fromNode":"e82426482f152275","fromSide":"right","toNode":"1feb39080ed25a61","toSide":"left","label":"_validateConfiguration"},
		{"id":"fad168f1973d11c6","fromNode":"e82426482f152275","fromSide":"bottom","toNode":"cbf81aa4619af938","toSide":"top","label":"sendConfiguration-then()"},
		{"id":"dd9b4a16250e8d04","fromNode":"cbf81aa4619af938","fromSide":"left","toNode":"c14b0a8df714a1a0","toSide":"right","label":"sendConfig"},
		{"id":"7fea26a4229d7a37","fromNode":"c14b0a8df714a1a0","fromSide":"left","toNode":"c94507188c16856d","toSide":"right","label":"sendConfigLegacy"},
		{"id":"9fcb70bc289d98a9","fromNode":"c14b0a8df714a1a0","fromSide":"left","toNode":"e2240b8b8fdbb02a","toSide":"right","label":"sendConfig12830"},
		{"id":"55db6b5a4cef2fa7","fromNode":"d415a0a83e17a603","fromSide":"top","toNode":"1a2a0fb59f7cc4d1","toSide":"bottom"},
		{"id":"3f7319721e39a3f2","fromNode":"3b07f34bafa0432e","fromSide":"top","toNode":"165ceebc50e70c0a","toSide":"bottom"},
		{"id":"d85ba26caad9282d","fromNode":"1feb39080ed25a61","fromSide":"left","toNode":"3e4f2957855a8de7","toSide":"left"}
	]
}